
/*
  ____  ____  _  _  ____  __  __  ___
 (  _ \(_  _)( \/ )(  _ \(  \/  )/ __)
  )(_) )_)(_  \  /  ) _ < )    ( \__ \
 (____/(____) (__) (____/(_/\/\_)(___/

DIYBMS V4.0
ESP8266 MODULE

(c)2019 Stuart Pittaway

COMPILE THIS CODE USING PLATFORM.IO

LICENSE
Attribution-NonCommercial-ShareAlike 2.0 UK: England & Wales (CC BY-NC-SA 2.0 UK)
https://creativecommons.org/licenses/by-nc-sa/2.0/uk/

* Non-Commercial — You may not use the material for commercial purposes.
* Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made.
  You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.
* ShareAlike — If you remix, transform, or build upon the material, you must distribute your   contributions under the same license as the original.
* No additional restrictions — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.
*/

#include <ESPAsyncWebServer.h>
#include <ArduinoJson.h>
#include "FS.h"

#if defined(ESP8266)
#include "ESP8266TrueRandom.h"
#include <TimeLib.h>
#include <LittleFS.h>
#endif

#if defined(ESP32)
#include <SPIFFS.h>
#include "time.h"
#endif

#include "defines.h"
#include "DIYBMSServer.h"
#include "EmbeddedFiles_AutoGenerated.h"

#include "settings.h"

AsyncWebServer *DIYBMSServer::_myserver;
String DIYBMSServer::UUIDString;

#define REBOOT_COUNT_DOWN 2000

String DIYBMSServer::uuidToString(uint8_t *uuidLocation)
{
  String string = "";
  int i;
  for (i = 0; i < 16; i++)
  {
    if (i == 4)
      string += "-";
    if (i == 6)
      string += "-";
    if (i == 8)
      string += "-";
    if (i == 10)
      string += "-";
    int topDigit = uuidLocation[i] >> 4;
    int bottomDigit = uuidLocation[i] & 0x0f;
    // High hex digit
    string += "0123456789abcdef"[topDigit];
    // Low hex digit
    string += "0123456789abcdef"[bottomDigit];
  }

  return string;
}

void DIYBMSServer::generateUUID()
{
  //SERIAL_DEBUG.print("generateUUID=");
  byte uuidNumber[16]; // UUIDs in binary form are 16 bytes long
#if defined(ESP8266)
  ESP8266TrueRandom.uuid(uuidNumber);
#endif

#if defined(ESP32)
  //ESP32 has inbuilt random number generator
  //https://techtutorialsx.com/2017/12/22/esp32-arduino-random-number-generation/
  for (uint8_t x = 0; x < 16; x--)
    uuidNumber[x] = random(0xFF);
#endif

  UUIDString = uuidToString(uuidNumber);
}

bool DIYBMSServer::validateXSS(AsyncWebServerRequest *request)
{
  if (request->hasHeader("Cookie"))
  {
    AsyncWebHeader *cookie = request->getHeader("Cookie");
    if (cookie->value().startsWith("DIYBMS_XSS="))
    {
      if (cookie->value().substring(11).equals(DIYBMSServer::UUIDString))
      {
        if (request->hasParam("xss", true))
        {
          AsyncWebParameter *p1 = request->getParam("xss", true);

          if (p1->value().equals(DIYBMSServer::UUIDString) == true)
          {
            return true;
          }
        }
      }
    }
  }
  request->send(500, "text/plain", "XSS invalid");
  return false;
}

void DIYBMSServer::SendSuccess(AsyncWebServerRequest *request)
{
  AsyncResponseStream *response = request->beginResponseStream("application/json");
  StaticJsonDocument<100> doc;
  doc["success"] = true;
  serializeJson(doc, *response);
  request->send(response);
}

void DIYBMSServer::SendFailure(AsyncWebServerRequest *request)
{
  request->send(500, "text/plain", "Failed");
}

void DIYBMSServer::resetCounters(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  //Ask modules to reset bad packet counters
  prg.sendBadPacketCounterReset();

  for (uint8_t i = 0; i < maximum_controller_cell_modules; i++)
  {
    cmi[i].badPacketCount = 0;
  }

  //Reset internal counters on CONTROLLER
  receiveProc.ResetCounters();

  prg.packetsGenerated = 0;

  SendSuccess(request);
}

void DIYBMSServer::saveDisplaySetting(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("VoltageHigh", true))
  {
    AsyncWebParameter *p1 = request->getParam("VoltageHigh", true);
    mysettings.graph_voltagehigh = p1->value().toFloat();
  }

  if (request->hasParam("VoltageLow", true))
  {
    AsyncWebParameter *p1 = request->getParam("VoltageLow", true);
    mysettings.graph_voltagelow = p1->value().toFloat();
  }

  //Validate high is greater than low
  if (mysettings.graph_voltagelow > mysettings.graph_voltagehigh)
  {
    mysettings.graph_voltagelow = 0;
  }

  Settings::WriteConfigToEEPROM((char *)&mysettings, sizeof(mysettings), EEPROM_SETTINGS_START_ADDRESS);

  SendSuccess(request);
}

void DIYBMSServer::saveInfluxDBSetting(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("influxEnabled", true))
  {
    AsyncWebParameter *p1 = request->getParam("influxEnabled", true);
    mysettings.influxdb_enabled = p1->value().equals("on") ? true : false;
  }
  else
  {
    mysettings.influxdb_enabled = false;
  }

  if (request->hasParam("influxPort", true))
  {
    AsyncWebParameter *p1 = request->getParam("influxPort", true);
    mysettings.influxdb_httpPort = p1->value().toInt();
  }

  if (request->hasParam("influxServer", true))
  {
    AsyncWebParameter *p1 = request->getParam("influxServer", true);
    p1->value().toCharArray(mysettings.influxdb_host, sizeof(mysettings.influxdb_host));
  }

  if (request->hasParam("influxDatabase", true))
  {
    AsyncWebParameter *p1 = request->getParam("influxDatabase", true);
    p1->value().toCharArray(mysettings.influxdb_database, sizeof(mysettings.influxdb_database));
  }

  if (request->hasParam("influxUsername", true))
  {
    AsyncWebParameter *p1 = request->getParam("influxUsername", true);
    p1->value().toCharArray(mysettings.influxdb_user, sizeof(mysettings.influxdb_user));
  }

  if (request->hasParam("influxPassword", true))
  {
    AsyncWebParameter *p1 = request->getParam("influxPassword", true);
    p1->value().toCharArray(mysettings.influxdb_password, sizeof(mysettings.influxdb_password));
  }

  Settings::WriteConfigToEEPROM((char *)&mysettings, sizeof(mysettings), EEPROM_SETTINGS_START_ADDRESS);

  ConfigHasChanged = REBOOT_COUNT_DOWN;
  SendSuccess(request);
}

void DIYBMSServer::saveRuleConfiguration(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  //relaytype
  for (int i = 0; i < RELAY_TOTAL; i++)
  {
    String name = "relaytype";
    name = name + (i + 1);
    if (request->hasParam(name.c_str(), true, false))
    {
      AsyncWebParameter *p1 = request->getParam(name.c_str(), true, false);
      //Default
      mysettings.relaytype[i] = RelayType::RELAY_STANDARD;
      if (p1->value().equals("Pulse"))
      {
        mysettings.relaytype[i] = RelayType::RELAY_PULSE;
      }
    }
  }

  //Relay default
  for (int i = 0; i < RELAY_TOTAL; i++)
  {
    String name = "defaultrelay";
    name = name + (i + 1);
    if (request->hasParam(name.c_str(), true, false))
    {
      AsyncWebParameter *p1 = request->getParam(name.c_str(), true, false);
      //Default
      mysettings.rulerelaydefault[i] = RelayState::RELAY_OFF;
      if (p1->value().equals("On"))
      {
        mysettings.rulerelaydefault[i] = RelayState::RELAY_ON;
      }
    }
  }

  for (int rule = 0; rule < RELAY_RULES; rule++)
  {

    //TODO: This STRING doesnt work properly if its on a single line!
    String name = "rule";
    name = name + (rule + 1);
    name = name + "value";

    if (request->hasParam(name, true))
    {
      AsyncWebParameter *p1 = request->getParam(name, true);
      mysettings.rulevalue[rule] = p1->value().toInt();
    }

    //TODO: This STRING doesnt work properly if its on a single line!
    String hname = "rule";
    hname = hname + (rule + 1);
    hname = hname + "hysteresis";
    if (request->hasParam(hname, true))
    {
      AsyncWebParameter *p1 = request->getParam(hname, true);
      mysettings.rulehysteresis[rule] = p1->value().toInt();
    }

    //Rule/relay processing
    for (int i = 0; i < RELAY_TOTAL; i++)
    {
      //TODO: This STRING doesnt work properly if its on a single line!
      String name = "rule";
      name = name + (rule + 1);
      name = name + "relay";
      name = name + (i + 1);
      if (request->hasParam(name, true))
      {
        AsyncWebParameter *p1 = request->getParam(name, true);
        mysettings.rulerelaystate[rule][i] = p1->value().equals("X") ? RELAY_X : p1->value().equals("On") ? RelayState::RELAY_ON : RelayState::RELAY_OFF;
      }
    }

    //Reset state of rules after updating the new values
    for (int8_t r = 0; r < RELAY_RULES; r++)
    {
      rules.rule_outcome[r] = false;
    }
  }

  //RELAY_TOTAL

  Settings::WriteConfigToEEPROM((char *)&mysettings, sizeof(mysettings), EEPROM_SETTINGS_START_ADDRESS);

  SendSuccess(request);
}

void DIYBMSServer::saveNTP(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("NTPServer", true))
  {
    AsyncWebParameter *p1 = request->getParam("NTPServer", true);
    p1->value().toCharArray(mysettings.ntpServer, sizeof(mysettings.ntpServer));
  }

  if (request->hasParam("NTPZoneHour", true))
  {
    AsyncWebParameter *p1 = request->getParam("NTPZoneHour", true);
    mysettings.timeZone = p1->value().toInt();
  }

  if (request->hasParam("NTPZoneMin", true))
  {
    AsyncWebParameter *p1 = request->getParam("NTPZoneMin", true);
    mysettings.minutesTimeZone = p1->value().toInt();
  }

  mysettings.daylight = false;
  if (request->hasParam("NTPDST", true))
  {
    AsyncWebParameter *p1 = request->getParam("NTPDST", true);
    mysettings.daylight = p1->value().equals("on") ? true : false;
  }

  Settings::WriteConfigToEEPROM((char *)&mysettings, sizeof(mysettings), EEPROM_SETTINGS_START_ADDRESS);

  ConfigHasChanged = REBOOT_COUNT_DOWN;
  SendSuccess(request);
}

void DIYBMSServer::saveBankConfiguration(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  uint8_t totalSeriesModules = 1;
  uint8_t totalBanks = 1;

  if (request->hasParam("totalSeriesModules", true))
  {
    AsyncWebParameter *p1 = request->getParam("totalSeriesModules", true);
    totalSeriesModules = p1->value().toInt();
  }

  if (request->hasParam("totalBanks", true))
  {
    AsyncWebParameter *p1 = request->getParam("totalBanks", true);
    totalBanks = p1->value().toInt();
  }

  if (totalSeriesModules * totalBanks <= maximum_controller_cell_modules)
  {
    mysettings.totalNumberOfSeriesModules = totalSeriesModules;
    mysettings.totalNumberOfBanks = totalBanks;
    Settings::WriteConfigToEEPROM((char *)&mysettings, sizeof(mysettings), EEPROM_SETTINGS_START_ADDRESS);

    SendSuccess(request);
  }
  else
  {
    SendFailure(request);
  }
}

void DIYBMSServer::saveMQTTSetting(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("mqttEnabled", true))
  {
    AsyncWebParameter *p1 = request->getParam("mqttEnabled", true);
    mysettings.mqtt_enabled = p1->value().equals("on") ? true : false;
  }
  else
  {
    mysettings.mqtt_enabled = false;
  }

  if (request->hasParam("mqttTopic", true))
  {
    AsyncWebParameter *p1 = request->getParam("mqttTopic", true);
    p1->value().toCharArray(mysettings.mqtt_topic, sizeof(mysettings.mqtt_topic));
  }
  else
  {
    sprintf(mysettings.mqtt_topic, "diybms");
  }

  if (request->hasParam("mqttPort", true))
  {
    AsyncWebParameter *p1 = request->getParam("mqttPort", true);
    mysettings.mqtt_port = p1->value().toInt();
  }

  if (request->hasParam("mqttServer", true))
  {
    AsyncWebParameter *p1 = request->getParam("mqttServer", true);
    p1->value().toCharArray(mysettings.mqtt_server, sizeof(mysettings.mqtt_server));
  }

  if (request->hasParam("mqttUsername", true))
  {
    AsyncWebParameter *p1 = request->getParam("mqttUsername", true);
    p1->value().toCharArray(mysettings.mqtt_username, sizeof(mysettings.mqtt_username));
  }

  if (request->hasParam("mqttPassword", true))
  {
    AsyncWebParameter *p1 = request->getParam("mqttPassword", true);
    p1->value().toCharArray(mysettings.mqtt_password, sizeof(mysettings.mqtt_password));
  }

  Settings::WriteConfigToEEPROM((char *)&mysettings, sizeof(mysettings), EEPROM_SETTINGS_START_ADDRESS);

  ConfigHasChanged = REBOOT_COUNT_DOWN;
  SendSuccess(request);
}

void DIYBMSServer::saveGlobalSetting(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("BypassOverTempShutdown", true) && request->hasParam("BypassThresholdmV", true))
  {

    AsyncWebParameter *p1 = request->getParam("BypassOverTempShutdown", true);
    mysettings.BypassOverTempShutdown = p1->value().toInt();

    AsyncWebParameter *p2 = request->getParam("BypassThresholdmV", true);
    mysettings.BypassThresholdmV = p2->value().toInt();

    Settings::WriteConfigToEEPROM((char *)&mysettings, sizeof(mysettings), EEPROM_SETTINGS_START_ADDRESS);

    prg.sendSaveGlobalSetting(mysettings.BypassThresholdmV, mysettings.BypassOverTempShutdown);

    uint8_t totalModules = mysettings.totalNumberOfBanks * mysettings.totalNumberOfSeriesModules;

    for (uint8_t i = 0; i < totalModules; i++)
    {
      if (cmi[i].valid)
      {
        cmi[i].BypassThresholdmV = mysettings.BypassThresholdmV;
        cmi[i].BypassOverTempShutdown = mysettings.BypassOverTempShutdown;
      }
    }

    //Just returns NULL
    SendSuccess(request);
  }
  else
  {
    request->send(500, "text/plain", "Missing parameters");
  }
}

void DIYBMSServer::handleNotFound(AsyncWebServerRequest *request)
{
  request->send(404, "text/plain", "Not found");
}

void DIYBMSServer::saveSetting(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("m", true))
  {
    AsyncWebParameter *module = request->getParam("m", true);
    //Will this overflow?
    uint8_t m = module->value().toInt();

    if (m > maximum_controller_cell_modules)
    {
      request->send(500, "text/plain", "Wrong parameters");
    }
    else
    {

      uint8_t BypassOverTempShutdown = 0xFF;
      uint16_t BypassThresholdmV = 0xFFFF;

      // Resistance of bypass load
      //float LoadResistance = 0xFFFF;
      //Voltage Calibration
      float Calibration = 0xFFFF;
      //Reference voltage (millivolt) normally 2.00mV
      //float mVPerADC = 0xFFFF;
      //Internal Thermistor settings
      //uint16_t Internal_BCoefficient = 0xFFFF;
      //External Thermistor settings
      //uint16_t External_BCoefficient = 0xFFFF;

      if (request->hasParam("BypassOverTempShutdown", true))
      {
        AsyncWebParameter *p1 = request->getParam("BypassOverTempShutdown", true);
        BypassOverTempShutdown = p1->value().toInt();
      }

      if (request->hasParam("BypassThresholdmV", true))
      {
        AsyncWebParameter *p1 = request->getParam("BypassThresholdmV", true);
        BypassThresholdmV = p1->value().toInt();
      }
      if (request->hasParam("Calib", true))
      {
        AsyncWebParameter *p1 = request->getParam("Calib", true);
        Calibration = p1->value().toFloat();
      }

      prg.sendSaveSetting(m, BypassThresholdmV, BypassOverTempShutdown, Calibration);

      clearModuleValues(m);

      SendSuccess(request);
    }
  }
  else
  {
    request->send(500, "text/plain", "Missing parameters");
  }
}

void DIYBMSServer::clearModuleValues(uint8_t module)
{
  cmi[module].valid = false;
  cmi[module].voltagemV = 0;
  cmi[module].voltagemVMin = 6000;
  cmi[module].voltagemVMax = 0;
  cmi[module].badPacketCount = 0;
  cmi[module].inBypass = false;
  cmi[module].bypassOverTemp = false;
  cmi[module].internalTemp = -40;
  cmi[module].externalTemp = -40;
}

void DIYBMSServer::GetRules(AsyncWebServerRequest *request)
{
  AsyncResponseStream *response =
      request->beginResponseStream("application/json");

  DynamicJsonDocument doc(2048);
  JsonObject root = doc.to<JsonObject>();

#if defined(ESP8266)
  root["timenow"] = (hour() * 60) + minute();
#endif

#if defined(ESP32)
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo))
  {
    root["timenow"] = 0;
  }
  else
  {
    root["timenow"] = (timeinfo.tm_hour * 60) + timeinfo.tm_min;
  }
#endif

  root["OutputsEnabled"] = OutputsEnabled;
  root["InputsEnabled"] = InputsEnabled;
  root["ControlState"] = ControlState;
  

  JsonArray defaultArray = root.createNestedArray("relaydefault");
  for (uint8_t relay = 0; relay < RELAY_TOTAL; relay++)
  {
    switch (mysettings.rulerelaydefault[relay])
    {
    case RELAY_OFF:
      defaultArray.add(false);
      break;
    case RELAY_ON:
      defaultArray.add(true);
      break;
    default:
      defaultArray.add((char *)0);
      break;
    }
  }

  JsonArray typeArray = root.createNestedArray("relaytype");
  for (uint8_t relay = 0; relay < RELAY_TOTAL; relay++)
  {
    switch (mysettings.relaytype[relay])
    {
    case RELAY_STANDARD:
      typeArray.add("Std");
      break;
    case RELAY_PULSE:
      typeArray.add("Pulse");
      break;
    default:
      typeArray.add((char *)0);
      break;
    }
  }

  JsonArray bankArray = root.createNestedArray("rules");

  for (uint8_t r = 0; r < RELAY_RULES; r++)
  {
    JsonObject rule = bankArray.createNestedObject();
    rule["value"] = mysettings.rulevalue[r];
    rule["hysteresis"] = mysettings.rulehysteresis[r];
    rule["triggered"] = rules.rule_outcome[r];
    JsonArray data = rule.createNestedArray("relays");

    for (uint8_t relay = 0; relay < RELAY_TOTAL; relay++)
    {
      switch (mysettings.rulerelaystate[r][relay])
      {
      case RELAY_OFF:
        data.add(false);
        break;
      case RELAY_ON:
        data.add(true);
        break;
      default:
        data.add((char *)0);
        break;
      }
    }
  }

  serializeJson(doc, *response);
  request->send(response);
}

#ifndef GIT_VERSION
#error GIT_VERSION not defined
#endif

void DIYBMSServer::settings(AsyncWebServerRequest *request)
{
  AsyncResponseStream *response =
      request->beginResponseStream("application/json");

  DynamicJsonDocument doc(2048);
  JsonObject root = doc.to<JsonObject>();

  JsonObject settings = root.createNestedObject("settings");

  settings["Version"] = String(GIT_VERSION);

  settings["totalnumberofbanks"] = mysettings.totalNumberOfBanks;
  settings["totalseriesmodules"] = mysettings.totalNumberOfSeriesModules;

  settings["bypassthreshold"] = mysettings.BypassThresholdmV;
  settings["bypassovertemp"] = mysettings.BypassOverTempShutdown;

  settings["NTPServerName"] = mysettings.ntpServer;
  settings["TimeZone"] = mysettings.timeZone;
  settings["MinutesTimeZone"] = mysettings.minutesTimeZone;
  settings["DST"] = mysettings.daylight;

#if defined(ESP8266)
  settings["now"] = now();
#endif

#if defined(ESP32)
  time_t now;
  if (time(&now))
  {
    settings["now"] = now;
  }
#endif

  response->addHeader("Cache-Control", "no-store");

  serializeJson(doc, *response);
  request->send(response);
}

void DIYBMSServer::integration(AsyncWebServerRequest *request)
{
  AsyncResponseStream *response =
      request->beginResponseStream("application/json");

  DynamicJsonDocument doc(2048);
  JsonObject root = doc.to<JsonObject>();

  JsonObject mqtt = root.createNestedObject("mqtt");
  mqtt["enabled"] = mysettings.mqtt_enabled;
  mqtt["topic"] = mysettings.mqtt_topic;
  mqtt["port"] = mysettings.mqtt_port;
  mqtt["server"] = mysettings.mqtt_server;
  mqtt["username"] = mysettings.mqtt_username;
  //We don't output the password in the json file as this could breach security
  //mqtt["password"] =mysettings.mqtt_password;

  JsonObject influxdb = root.createNestedObject("influxdb");
  influxdb["enabled"] = mysettings.influxdb_enabled;
  influxdb["port"] = mysettings.influxdb_httpPort;
  influxdb["server"] = mysettings.influxdb_host;
  influxdb["database"] = mysettings.influxdb_database;
  influxdb["username"] = mysettings.influxdb_user;
  //We don't output the password in the json file as this could breach security
  //influxdb["password"] = mysettings.influxdb_password;

  serializeJson(doc, *response);
  request->send(response);
}

void DIYBMSServer::identifyModule(AsyncWebServerRequest *request)
{
  if (request->hasParam("c", false))
  {
    AsyncWebParameter *cellid = request->getParam("c", false);
    uint8_t c = cellid->value().toInt();

    if (c > mysettings.totalNumberOfBanks * mysettings.totalNumberOfSeriesModules)
    {
      request->send(500, "text/plain", "Wrong parameter bank");
      return;
    }
    else
    {
      prg.sendIdentifyModuleRequest(c);
      SendSuccess(request);
    }
  }
  else
  {
    request->send(500, "text/plain", "Missing parameters");
  }
}

void DIYBMSServer::modules(AsyncWebServerRequest *request)
{
  if (request->hasParam("c", false))
  {
    AsyncWebParameter *cellid = request->getParam("c", false);
    uint8_t c = cellid->value().toInt();

    if (c > mysettings.totalNumberOfBanks * mysettings.totalNumberOfSeriesModules)
    {
      request->send(500, "text/plain", "Wrong parameter bank");
      return;
    }

    if (cmi[c].settingsCached == false)
    {
      prg.sendGetSettingsRequest(c);
    }

    AsyncResponseStream *response = request->beginResponseStream("application/json");

    DynamicJsonDocument doc(2048);
    JsonObject root = doc.to<JsonObject>();
    JsonObject settings = root.createNestedObject("settings");

    uint8_t b = c / mysettings.totalNumberOfSeriesModules;
    uint8_t m = c - (b * mysettings.totalNumberOfSeriesModules);
    settings["bank"] = b;
    settings["module"] = m;
    settings["id"] = c;
    settings["ver"] = cmi[c].BoardVersionNumber;
    settings["Cached"] = cmi[c].settingsCached;

    if (cmi[c].settingsCached)
    {
      settings["BypassOverTempShutdown"] = cmi[c].BypassOverTempShutdown;
      settings["BypassThresholdmV"] = cmi[c].BypassThresholdmV;
      settings["LoadRes"] = cmi[c].LoadResistance;
      settings["Calib"] = cmi[c].Calibration;
      settings["mVPerADC"] = cmi[c].mVPerADC;
      settings["IntBCoef"] = cmi[c].Internal_BCoefficient;
      settings["ExtBCoef"] = cmi[c].External_BCoefficient;
    }

    serializeJson(doc, *response);
    request->send(response);
  }
}

/*
Restart controller from web interface
*/
void DIYBMSServer::handleRestartController(AsyncWebServerRequest *request)
{
  ESP.restart();
}

void DIYBMSServer::monitor2(AsyncWebServerRequest *request)
{

  DynamicJsonDocument doc(13312);

  if (doc.capacity() == 0)
  {
    //If memory allocation fails, swap to a small JSON document
    //so the interface can report the error.
    AsyncResponseStream *response = request->beginResponseStream("application/json");
    DynamicJsonDocument doc2(512);

    doc2["banks"] = mysettings.totalNumberOfBanks;
    doc2["seriesmodules"] = mysettings.totalNumberOfSeriesModules;
    doc2["errorcode"] = InternalErrorCode::ControllerMemoryError;
    doc2["warningcode"] = rules.WarningCode;
    doc2["sent"] = prg.packetsGenerated;
    doc2["received"] = receiveProc.packetsReceived;
    doc2["modulesfnd"] = receiveProc.totalModulesFound;
    doc2["badcrc"] = receiveProc.totalCRCErrors;
    doc2["ignored"] = receiveProc.totalNotProcessedErrors;
    doc2["roundtrip"] = receiveProc.packetTimerMillisecond;
    doc2["oos"] = receiveProc.totalOutofSequenceErrors;

    serializeJson(doc2, *response);
    request->send(response);
  }
  else
  {
    AsyncResponseStream *response = request->beginResponseStream("application/json");

    doc["banks"] = mysettings.totalNumberOfBanks;
    doc["seriesmodules"] = mysettings.totalNumberOfSeriesModules;
    doc["errorcode"] = rules.ErrorCode;
    doc["warningcode"] = rules.WarningCode;
    doc["sent"] = prg.packetsGenerated;
    doc["received"] = receiveProc.packetsReceived;
    doc["modulesfnd"] = receiveProc.totalModulesFound;
    doc["badcrc"] = receiveProc.totalCRCErrors;
    doc["ignored"] = receiveProc.totalNotProcessedErrors;
    doc["roundtrip"] = receiveProc.packetTimerMillisecond;
    doc["oos"] = receiveProc.totalOutofSequenceErrors;

    //doc["FreeHeap"]=ESP.getFreeHeap();
    //doc["FreeBlockSize"]=ESP.getMaxFreeBlockSize();

    uint8_t totalModules = mysettings.totalNumberOfBanks * mysettings.totalNumberOfSeriesModules;

    JsonArray voltages = doc.createNestedArray("voltages");

    JsonArray minvoltages = doc.createNestedArray("minvoltages");
    JsonArray maxvoltages = doc.createNestedArray("maxvoltages");
    JsonArray badpacket = doc.createNestedArray("badpacket");

    JsonArray bypass = doc.createNestedArray("bypass");
    JsonArray bypasshot = doc.createNestedArray("bypasshot");
    JsonArray inttemp = doc.createNestedArray("inttemp");
    JsonArray exttemp = doc.createNestedArray("exttemp");
    JsonArray bypasspwm = doc.createNestedArray("bypasspwm");

    for (uint8_t i = 0; i < totalModules; i++)
    {
      if (cmi[i].valid)
      {
        voltages.add(cmi[i].voltagemV);

        if (totalModules <= 64)
        {
          //To preserve memory, only return these parameters when there are less than =64 modules
          minvoltages.add(cmi[i].voltagemVMin);
          maxvoltages.add(cmi[i].voltagemVMax);
          badpacket.add(cmi[i].badPacketCount);
        }

        if (cmi[i].internalTemp != -40)
        {
          inttemp.add(cmi[i].internalTemp);
        }
        else
        {
          inttemp.add((char *)0);
        }

        if (cmi[i].externalTemp != -40)
        {
          exttemp.add(cmi[i].externalTemp);
        }
        else
        {
          exttemp.add((char *)0);
        }

        bypasspwm.add(cmi[i].inBypass ? cmi[i].PWMValue : 0);
        //Convert boolean to 1 or 0 to save bandwidth (every byte counts on this request)
        bypass.add(cmi[i].inBypass ? 1 : 0);
        bypasshot.add(cmi[i].bypassOverTemp ? 1 : 0);
      }
      else
      {
        //Module is not yet valid so return null values...
        voltages.add((char *)0);
        if (totalModules <= 64)
        {
          minvoltages.add((char *)0);
          maxvoltages.add((char *)0);
          badpacket.add(0);
        }
        inttemp.add((char *)0);
        exttemp.add((char *)0);
        bypasspwm.add(0);
        //Convert boolean to 1 or 0 to save bandwidth (every byte counts on this request)
        bypass.add(0);
        bypasshot.add(0);
      }
    }

    JsonArray bankvoltage = doc.createNestedArray("bankv");
    JsonArray voltagerange = doc.createNestedArray("voltrange");
    for (uint8_t b = 0; b < mysettings.totalNumberOfBanks; b++)
    {
      bankvoltage.add(rules.packvoltage[b]);
      voltagerange.add(rules.VoltageRangeInBank(b));
    }

    //Current reading in mA
    JsonArray current = doc.createNestedArray("current");
    //current.add(10000);
    //NULL
    current.add((char *)0);

    response->addHeader("Cache-Control", "no-store");

    serializeJson(doc, *response);
    request->send(response);
  }
}

String DIYBMSServer::TemplateProcessor(const String &var)
{
  if (var == "XSS_KEY")
    return DIYBMSServer::UUIDString;

#if defined(ESP8266)
  if (var == "PLATFORM")
    return String("ESP8266");
#endif

#if defined(ESP32)
  if (var == "PLATFORM")
    return String("ESP32");
#endif

  //  const DEFAULT_GRAPH_MAX_VOLTAGE = %graph_voltagehigh%;
  //  const DEFAULT_GRAPH_MIN_VOLTAGE = %graph_voltagelow%;

  if (var == "graph_voltagehigh")
    return String(mysettings.graph_voltagehigh);

  if (var == "graph_voltagelow")
    return String(mysettings.graph_voltagelow);

  return String();
}

void DIYBMSServer::StartServer(AsyncWebServer *webserver)
{
  _myserver = webserver;

  String cookieValue = "DIYBMS_XSS=";
  cookieValue += DIYBMSServer::UUIDString;
  cookieValue += String("; path=/; HttpOnly");
  DefaultHeaders::Instance().addHeader("Set-Cookie", cookieValue);

  _myserver->on("/", HTTP_GET, [](AsyncWebServerRequest *request) { request->redirect("/default.htm"); });

  //file_default_htm
  //_myserver->serveStatic("/default.htm", LittleFS, "/default.htm").setTemplateProcessor(DIYBMSServer::TemplateProcessor);
  //_myserver->serveStatic("/", LittleFS, "/").setCacheControl("max-age=600");

  _myserver->on("/default.htm", HTTP_GET,
                [](AsyncWebServerRequest *request) {
                  AsyncWebServerResponse *response = request->beginResponse_P(200, "text/html", (char *)file_default_htm, DIYBMSServer::TemplateProcessor);
                  response->addHeader("Cache-Control", "no-store");
                  request->send(response);
                });

  _myserver->on("/pagecode.js", HTTP_GET,
                [](AsyncWebServerRequest *request) {
                  //const char *htmlBuildTime = __DATE__ " " __TIME__;
                  if (request->header("If-None-Match").equals(String(etag_file_pagecode_js_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "application/javascript", file_pagecode_js_gz, size_file_pagecode_js_gz);
                    response->addHeader("Content-Encoding", "gzip");
                    response->addHeader("ETag", String(etag_file_pagecode_js_gz));
                    response->addHeader("Cache-Control", "no-cache, max-age=86400");
                    request->send(response);
                  }
                });

  _myserver->on("/favicon.ico", HTTP_GET,
                [](AsyncWebServerRequest *request) {
                  if (request->header("If-None-Match").equals(String(etag_file_favicon_ico_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "image/x-icon", file_favicon_ico_gz, size_file_favicon_ico_gz);
                    response->addHeader("Content-Encoding", "gzip");
                    response->addHeader("ETag", String(etag_file_favicon_ico_gz));
                    response->addHeader("Cache-Control", "public, max-age=86400, immutable");
                    request->send(response);
                  }
                });

  _myserver->on("/logo.png", HTTP_GET,
                [](AsyncWebServerRequest *request) {
                  if (request->header("If-None-Match").equals(String(etag_file_logo_png)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "image/png", file_logo_png, size_file_logo_png);
                    response->addHeader("ETag", String(etag_file_logo_png));
                    response->addHeader("Cache-Control", "no-cache, max-age=86400");
                    request->send(response);
                  }
                });

  _myserver->on("/wait.png", HTTP_GET,
                [](AsyncWebServerRequest *request) {
                  if (request->header("If-None-Match").equals(String(etag_file_wait_png)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "image/png", file_wait_png, size_file_wait_png);
                    response->addHeader("ETag", String(etag_file_wait_png));
                    response->addHeader("Cache-Control", "no-cache, max-age=86400");
                    request->send(response);
                  }
                });

  _myserver->on("/patron.png", HTTP_GET,
                [](AsyncWebServerRequest *request) {
                  if (request->header("If-None-Match").equals(String(etag_file_patron_png)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "image/png", file_patron_png, size_file_patron_png);
                    response->addHeader("ETag", String(etag_file_patron_png));
                    response->addHeader("Cache-Control", "no-cache, max-age=86400");
                    request->send(response);
                  }
                });

  _myserver->on("/jquery.js", HTTP_GET,
                [](AsyncWebServerRequest *request) {
                  if (request->header("If-None-Match").equals(String(etag_file_jquery_js_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "application/javascript", file_jquery_js_gz, size_file_jquery_js_gz);
                    response->addHeader("Content-Encoding", "gzip");
                    response->addHeader("ETag", String(etag_file_jquery_js_gz));
                    response->addHeader("Cache-Control", "public, max-age=86400, immutable");
                    request->send(response);
                  }
                });

  _myserver->on("/echarts.min.js", HTTP_GET,
                [](AsyncWebServerRequest *request) {
                  if (request->header("If-None-Match").equals(String(etag_file_echarts_min_js_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "application/javascript", file_echarts_min_js_gz, size_file_echarts_min_js_gz);
                    response->addHeader("Content-Encoding", "gzip");
                    response->addHeader("ETag", String(etag_file_echarts_min_js_gz));
                    response->addHeader("Cache-Control", "public, max-age=86400, immutable");
                    request->send(response);
                  }
                });

  _myserver->on("/echarts_gl.min.js", HTTP_GET,
                [](AsyncWebServerRequest *request) {
                  if (request->header("If-None-Match").equals(String(etag_file_echarts_gl_min_js_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "application/javascript", file_echarts_gl_min_js_gz, size_file_echarts_gl_min_js_gz);
                    response->addHeader("Content-Encoding", "gzip");
                    response->addHeader("ETag", String(etag_file_echarts_gl_min_js_gz));
                    response->addHeader("Cache-Control", "public, max-age=86400, immutable");
                    request->send(response);
                  }
                });

  _myserver->on("/style.css", HTTP_GET,
                [](AsyncWebServerRequest *request) {
                  if (request->header("If-None-Match").equals(String(etag_file_style_css_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "text/css", file_style_css_gz, size_file_style_css_gz);
                    response->addHeader("Content-Encoding", "gzip");
                    response->addHeader("ETag", String(etag_file_style_css_gz));
                    response->addHeader("Cache-Control", "no-cache, max-age=86400");
                    request->send(response);
                  }
                });

//Put this last...
#if defined(ESP8266)
  //_myserver->serveStatic("/", LittleFS, "/").setCacheControl("max-age=600");
#else
  //_myserver->serveStatic("/", SPIFFS, "/").setCacheControl("max-age=600");
#endif

  //Read endpoints
  _myserver->on("/monitor2.json", HTTP_GET, DIYBMSServer::monitor2);
  _myserver->on("/integration.json", HTTP_GET, DIYBMSServer::integration);
  _myserver->on("/modules.json", HTTP_GET, DIYBMSServer::modules);
  _myserver->on("/identifyModule.json", HTTP_GET, DIYBMSServer::identifyModule);
  _myserver->on("/settings.json", HTTP_GET, DIYBMSServer::settings);
  _myserver->on("/rules.json", HTTP_GET, DIYBMSServer::GetRules);

  //POST method endpoints
  _myserver->on("/savesetting.json", HTTP_POST, DIYBMSServer::saveSetting);
  _myserver->on("/saveglobalsetting.json", HTTP_POST, DIYBMSServer::saveGlobalSetting);
  _myserver->on("/savemqtt.json", HTTP_POST, DIYBMSServer::saveMQTTSetting);
  _myserver->on("/saveinfluxdb.json", HTTP_POST, DIYBMSServer::saveInfluxDBSetting);
  _myserver->on("/savebankconfig.json", HTTP_POST, DIYBMSServer::saveBankConfiguration);
  _myserver->on("/saverules.json", HTTP_POST, DIYBMSServer::saveRuleConfiguration);
  _myserver->on("/saventp.json", HTTP_POST, DIYBMSServer::saveNTP);
  _myserver->on("/savedisplaysetting.json", HTTP_POST, DIYBMSServer::saveDisplaySetting);

  _myserver->on("/resetcounters.json", HTTP_POST, DIYBMSServer::resetCounters);
  _myserver->on("/restartcontroller.json", HTTP_POST, DIYBMSServer::handleRestartController);

  _myserver->onNotFound(DIYBMSServer::handleNotFound);
  _myserver->begin();
}
