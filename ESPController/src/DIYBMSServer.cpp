
/*
  ____  ____  _  _  ____  __  __  ___
 (  _ \(_  _)( \/ )(  _ \(  \/  )/ __)
  )(_) )_)(_  \  /  ) _ < )    ( \__ \
 (____/(____) (__) (____/(_/\/\_)(___/

DIYBMS V4.0
ESP8266 MODULE

(c)2019 Stuart Pittaway

COMPILE THIS CODE USING PLATFORM.IO

LICENSE
Attribution-NonCommercial-ShareAlike 2.0 UK: England & Wales (CC BY-NC-SA 2.0 UK)
https://creativecommons.org/licenses/by-nc-sa/2.0/uk/

* Non-Commercial — You may not use the material for commercial purposes.
* Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made.
  You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.
* ShareAlike — If you remix, transform, or build upon the material, you must distribute your   contributions under the same license as the original.
* No additional restrictions — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.
*/

#include <ESPAsyncWebServer.h>
#include <ArduinoJson.h>
#include "FS.h"

#include <SPIFFS.h>
#include "time.h"

#include "defines.h"
#include "DIYBMSServer.h"
#include "EmbeddedFiles_AutoGenerated.h"
#include "EmbeddedFiles_Integrity.h"

#include "settings.h"

#include "FS.h"
#include <LITTLEFS.h>
#include "SD.h"

#include "SoftAP.h"

AsyncWebServer *DIYBMSServer::_myserver;
String DIYBMSServer::UUIDString;
String DIYBMSServer::UUIDStringLast2Chars;

fs::SDFS *DIYBMSServer::_sdcard = 0;
void (*DIYBMSServer::_sdcardaction_callback)(uint8_t action) = 0;
PacketRequestGenerator *DIYBMSServer::_prg = 0;
PacketReceiveProcessor *DIYBMSServer::_receiveProc = 0;
diybms_eeprom_settings *DIYBMSServer::_mysettings = 0;
Rules *DIYBMSServer::_rules = 0;
ControllerState *DIYBMSServer::_controlState = 0;
HAL_ESP32 *DIYBMSServer::_hal = 0;

#define REBOOT_COUNT_DOWN 2000

String DIYBMSServer::uuidToString(uint8_t *uuidLocation)
{
  const char hexchars[] = "0123456789abcdef";
  String string = "";
  int i;
  for (i = 0; i < 16; i++)
  {
    if (i == 4)
      string += "-";
    if (i == 6)
      string += "-";
    if (i == 8)
      string += "-";
    if (i == 10)
      string += "-";
    uint8_t topDigit = uuidLocation[i] >> 4;
    uint8_t bottomDigit = uuidLocation[i] & 0x0f;
    // High hex digit
    string += hexchars[topDigit];
    // Low hex digit
    string += hexchars[bottomDigit];
  }

  return string;
}

void DIYBMSServer::generateUUID()
{
  uint8_t uuidNumber[16]; // UUIDs in binary form are 16 bytes long

  // ESP32 has inbuilt random number generator
  // https://techtutorialsx.com/2017/12/22/esp32-arduino-random-number-generation/
  for (uint8_t x = 0; x < 16; x++)
  {
    uuidNumber[x] = random(0xFF);
  }

  UUIDString = uuidToString(uuidNumber);

  // 481efb3f-0400-0000-101f-fb3fd01efb3f
  UUIDStringLast2Chars = UUIDString.substring(34);
}

bool DIYBMSServer::validateXSS(AsyncWebServerRequest *request)
{
  if (request->hasHeader("Cookie"))
  {
    AsyncWebHeader *cookie = request->getHeader("Cookie");
    if (cookie->value().startsWith("DIYBMS_XSS="))
    {
      if (cookie->value().substring(11).equals(DIYBMSServer::UUIDString))
      {
        if (request->hasParam("xss", true))
        {
          AsyncWebParameter *p1 = request->getParam("xss", true);

          if (p1->value().equals(DIYBMSServer::UUIDString) == true)
          {
            return true;
          }
        }
      }
    }
  }
  request->send(500, "text/plain", "XSS invalid");
  return false;
}

void DIYBMSServer::SendSuccess(AsyncWebServerRequest *request)
{
  AsyncResponseStream *response = request->beginResponseStream("application/json");
  StaticJsonDocument<100> doc;
  doc["success"] = true;
  serializeJson(doc, *response);
  request->send(response);
}

void DIYBMSServer::SendFailure(AsyncWebServerRequest *request)
{
  request->send(500, "text/plain", "Failed");
}

void DIYBMSServer::saveConfigurationToSDCard(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (!_sd_card_installed)
  {
    SendFailure(request);
    return;
  }

  if (_hal->GetVSPIMutex())
  {

    struct tm timeinfo;

    // getLocalTime has delay() functions in it :-(
    if (getLocalTime(&timeinfo, 1))
    {
      timeinfo.tm_year += 1900;
      // Month is 0 to 11 based!
      timeinfo.tm_mon++;
    }
    else
    {
      memset(&timeinfo, 0, sizeof(tm));
    }

    char filename[128];
    sprintf(filename, "/backup_config_%04u%02u%02u_%02u%02u%02u.json", timeinfo.tm_year, timeinfo.tm_mon, timeinfo.tm_mday, timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);

    // ESP_LOGI(TAG, "Creating folder");
    //_sdcard->mkdir("/diybms");

    // Get the file
    ESP_LOGI(TAG, "Generating SD file %s", filename);

    if (_sdcard->exists(filename))
    {
      ESP_LOGI(TAG, "Delete existing file %s", filename);
      _sdcard->remove(filename);
    }

    StaticJsonDocument<4096> doc;

    // This code builds up a JSON document which mirrors the structure "diybms_eeprom_settings"
    JsonObject root = doc.createNestedObject("diybms_settings");

    root["totalNumberOfBanks"] = _mysettings->totalNumberOfBanks;
    root["totalNumberOfSeriesModules"] = _mysettings->totalNumberOfSeriesModules;
    root["baudRate"] = _mysettings->baudRate;

    root["graph_voltagehigh"] = _mysettings->graph_voltagehigh;
    root["graph_voltagelow"] = _mysettings->graph_voltagelow;

    root["BypassOverTempShutdown"] = _mysettings->BypassOverTempShutdown;
    root["BypassThresholdmV"] = _mysettings->BypassThresholdmV;

    root["timeZone"] = _mysettings->timeZone;
    root["minutesTimeZone"] = _mysettings->minutesTimeZone;
    root["daylight"] = _mysettings->daylight;
    root["ntpServer"] = _mysettings->ntpServer;

    root["loggingEnabled"] = _mysettings->loggingEnabled;
    root["loggingFrequencySeconds"] = _mysettings->loggingFrequencySeconds;

    root["currentMonitoringEnabled"] = _mysettings->currentMonitoringEnabled;
    root["currentMonitoringModBusAddress"] = _mysettings->currentMonitoringModBusAddress;

    root["rs485baudrate"] = _mysettings->rs485baudrate;
    root["rs485databits"] = _mysettings->rs485databits;
    root["rs485parity"] = _mysettings->rs485parity;
    root["rs485stopbits"] = _mysettings->rs485stopbits;

    root["language"] = _mysettings->language;

    root["VictronEnabled"] = _mysettings->VictronEnabled;

    JsonObject mqtt = root.createNestedObject("mqtt");
    mqtt["enabled"] = _mysettings->mqtt_enabled;
    mqtt["port"] = _mysettings->mqtt_port;
    mqtt["server"] = _mysettings->mqtt_server;
    mqtt["topic"] = _mysettings->mqtt_topic;
    mqtt["username"] = _mysettings->mqtt_username;
    mqtt["password"] = _mysettings->mqtt_password;

    JsonObject influxdb = root.createNestedObject("influxdb");
    influxdb["enabled"] = _mysettings->influxdb_enabled;
    influxdb["apitoken"] = _mysettings->influxdb_apitoken;
    influxdb["bucket"] = _mysettings->influxdb_databasebucket;
    influxdb["org"] = _mysettings->influxdb_orgid;
    influxdb["url"] = _mysettings->influxdb_serverurl;

    JsonObject outputs = root.createNestedObject("outputs");

    JsonArray d = outputs.createNestedArray("default");
    JsonArray t = outputs.createNestedArray("type");
    for (uint8_t i = 0; i < RELAY_TOTAL; i++)
    {
      d.add(_mysettings->rulerelaydefault[i]);
      t.add(_mysettings->relaytype[i]);
    }

    JsonObject rules = root.createNestedObject("rules");
    for (uint8_t rr = 0; rr < RELAY_RULES; rr++)
    {
      String elementName = String("rule") + String(rr);

      // Map enum to string so when this file is re-imported we are not locked to specific index offsets
      // which may no longer map to the correct rule
      switch (rr)
      {
      case Rule::EmergencyStop:
        elementName = String("EmergencyStop");
        break;
      case Rule::BMSError:
        elementName = String("BMSError");
        break;
      case Rule::CurrentMonitorOverCurrentAmps:
        elementName = String("CurrentMonitorOverCurrentAmps");
        break;
      case Rule::ModuleOverVoltage:
        elementName = String("ModuleOverVoltage");
        break;
      case Rule::ModuleUnderVoltage:
        elementName = String("ModuleUnderVoltage");
        break;
      case Rule::ModuleOverTemperatureInternal:
        elementName = String("ModuleOverTemperatureInternal");
        break;
      case Rule::ModuleUnderTemperatureInternal:
        elementName = String("ModuleUnderTemperatureInternal");
        break;
      case Rule::ModuleOverTemperatureExternal:
        elementName = String("ModuleOverTemperatureExternal");
        break;
      case Rule::ModuleUnderTemperatureExternal:
        elementName = String("ModuleUnderTemperatureExternal");
        break;
      case Rule::CurrentMonitorOverVoltage:
        elementName = String("CurrentMonitorOverVoltage");
        break;
      case Rule::CurrentMonitorUnderVoltage:
        elementName = String("CurrentMonitorUnderVoltage");
        break;
      case Rule::BankOverVoltage:
        elementName = String("BankOverVoltage");
        break;
      case Rule::BankUnderVoltage:
        elementName = String("BankUnderVoltage");
        break;
      case Rule::Timer2:
        elementName = String("Timer2");
        break;
      case Rule::Timer1:
        elementName = String("Timer1");
        break;
      }

      JsonObject state = rules.createNestedObject(elementName);

      state["value"] = _mysettings->rulevalue[rr];
      state["hysteresis"] = _mysettings->rulehysteresis[rr];

      JsonArray relaystate = state.createNestedArray("state");
      for (uint8_t rt = 0; rt < RELAY_TOTAL; rt++)
      {
        relaystate.add(_mysettings->rulerelaystate[rr][rt]);
      }
    } // end for

    JsonObject victron = root.createNestedObject("victron");
    JsonArray cvl = victron.createNestedArray("cvl");
    JsonArray ccl = victron.createNestedArray("ccl");
    JsonArray dcl = victron.createNestedArray("dcl");
    for (uint8_t i = 0; i < 3; i++)
    {
      cvl.add(_mysettings->cvl[i]);
      ccl.add(_mysettings->ccl[i]);
      dcl.add(_mysettings->dcl[i]);
    }

    /*
struct diybms_eeprom_settings
{
  //Use a bit pattern to indicate the relay states
  RelayState rulerelaystate[RELAY_RULES][RELAY_TOTAL];
};
*/

    // wifi["password"] = DIYBMSSoftAP::Config()->wifi_passphrase;

    File file = _sdcard->open(filename, "w");
    serializeJson(doc, file);
    file.close();

    _hal->ReleaseVSPIMutex();
  }

  SendSuccess(request);
}

void DIYBMSServer::saveWifiConfigToSDCard(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (!_sd_card_installed)
  {
    SendFailure(request);
    return;
  }

  if (_hal->GetVSPIMutex())
  {
    const char *wificonfigfilename = "/diybms/wifi.json";

    ESP_LOGI(TAG, "Creating folder");
    _sdcard->mkdir("/diybms");

    // Get the file
    ESP_LOGI(TAG, "Generating SD file %s", wificonfigfilename);
    StaticJsonDocument<1024> doc;

    JsonObject wifi = doc.createNestedObject("wifi");
    wifi["ssid"] = DIYBMSSoftAP::Config()->wifi_ssid;
    wifi["password"] = DIYBMSSoftAP::Config()->wifi_passphrase;

    if (_sdcard->exists(wificonfigfilename))
    {
      ESP_LOGI(TAG, "Delete existing file %s", wificonfigfilename);
      _sdcard->remove(wificonfigfilename);
    }

    File file = _sdcard->open(wificonfigfilename, "w");
    serializeJson(doc, file);
    file.close();

    _hal->ReleaseVSPIMutex();
  }

  SendSuccess(request);
}

void DIYBMSServer::avrProgrammer(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  uint16_t filenumber;

  if (request->hasParam("file", true))
  {
    AsyncWebParameter *filenumberparam = request->getParam("file", true);
    filenumber = filenumberparam->value().toInt();
  }
  else
  {
    SendFailure(request);
    return;
  }

  AsyncResponseStream *response = request->beginResponseStream("application/json");
  StaticJsonDocument<500> doc;

  if (_sd_card_installed)
  {
    doc["message"] = "Failed: Unable to program AVR whilst SD Card is mounted";
    serializeJson(doc, *response);
    request->send(response);
    return;
  }

  if (!_avrsettings.programmingModeEnabled)
  {
    doc["message"] = "Failed: Programming mode not enabled";
    serializeJson(doc, *response);
    request->send(response);
    return;
  }

  String manifestfilename = String("/avr/manifest.json");

  if (LITTLEFS.exists(manifestfilename))
  {
    StaticJsonDocument<3000> jsonmanifest;
    File file = LITTLEFS.open(manifestfilename);
    DeserializationError error = deserializeJson(jsonmanifest, file);
    if (error != DeserializationError::Ok)
    {
      ESP_LOGE(TAG, "Error deserialize Json");
      SendFailure(request);
      return;
    }
    else
    {
      // File open
      // ESP_LOGI(TAG, "Loaded manifest.json");

      JsonArray toplevel = jsonmanifest["avrprog"];

      int arraySize = jsonmanifest["avrprog"].size();

      if (filenumber > arraySize)
      {
        ESP_LOGE(TAG, "Index outsize array %i > %i", filenumber, arraySize);
        SendFailure(request);
        return;
      }

      JsonObject x = toplevel[filenumber];

      // serializeJsonPretty(x, SERIAL_DEBUG);

      _avrsettings.efuse = strtoul(x["efuse"].as<String>().c_str(), nullptr, 16);
      _avrsettings.hfuse = strtoul(x["hfuse"].as<String>().c_str(), nullptr, 16);
      _avrsettings.lfuse = strtoul(x["lfuse"].as<String>().c_str(), nullptr, 16);
      _avrsettings.mcu = strtoul(x["mcu"].as<String>().c_str(), nullptr, 16);

      String avrfilename = String("/avr/") + x["name"].as<String>();

      avrfilename.toCharArray(_avrsettings.filename, sizeof(_avrsettings.filename));
    }
    file.close();

    _avrsettings.progresult = 0xFF;
    _avrsettings.inProgress = true;

    // Fire task to start the AVR programming
    xTaskNotify(avrprog_task_handle, 0x00, eNotifyAction::eNoAction);
  }
  else
  {
    // No files!
    SendFailure(request);
    return;
  }

  doc["started"] = 1;
  doc["message"] = "Started";

  serializeJson(doc, *response);
  request->send(response);
}

void DIYBMSServer::avrstatus(AsyncWebServerRequest *request)
{
  AsyncResponseStream *response = request->beginResponseStream("application/json");
  StaticJsonDocument<256> doc;
  doc["inprogress"] = _avrsettings.inProgress ? 1 : 0;
  doc["result"] = _avrsettings.progresult;
  doc["duration"] = _avrsettings.duration;
  doc["size"] = _avrsettings.programsize;
  doc["mcu"] = _avrsettings.mcu;

  serializeJson(doc, *response);
  request->send(response);
}

void DIYBMSServer::enableAVRprog(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  (*DIYBMSServer::_sdcardaction_callback)(0);

  _avrsettings.programmingModeEnabled = true;

  SendSuccess(request);
}

void DIYBMSServer::disableAVRprog(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  _avrsettings.programmingModeEnabled = false;

  // Try and remount the SD card
  (*DIYBMSServer::_sdcardaction_callback)(1);

  SendSuccess(request);
}

void DIYBMSServer::sdMount(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (_avrsettings.programmingModeEnabled)
  {
    SendFailure(request);
  }
  else
  {

    (*DIYBMSServer::_sdcardaction_callback)(1);

    SendSuccess(request);
  }
}
void DIYBMSServer::sdUnmount(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (_avrsettings.programmingModeEnabled)
  {
    SendFailure(request);
  }
  else
  {
    (*DIYBMSServer::_sdcardaction_callback)(0);

    SendSuccess(request);
  }
}

void DIYBMSServer::resetCounters(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  // Ask modules to reset bad packet counters
  // If this fails, queue could be full so return error
  if (_prg->sendBadPacketCounterReset() && _prg->sendResetBalanceCurrentCounter())
  {

    canbus_messages_failed_sent = 0;
    canbus_messages_received = 0;
    canbus_messages_sent = 0;

    for (uint8_t i = 0; i < maximum_controller_cell_modules; i++)
    {
      cmi[i].badPacketCount = 0;
      cmi[i].PacketReceivedCount = 0;
    }

    // Reset internal counters on CONTROLLER
    _receiveProc->ResetCounters();

    _prg->ResetCounters();

    SendSuccess(request);
  }
  else
  {
    SendFailure(request);
  }
}

void DIYBMSServer::saveDisplaySetting(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("VoltageHigh", true))
  {
    AsyncWebParameter *p1 = request->getParam("VoltageHigh", true);
    _mysettings->graph_voltagehigh = p1->value().toFloat();
  }

  if (request->hasParam("VoltageLow", true))
  {
    AsyncWebParameter *p1 = request->getParam("VoltageLow", true);
    _mysettings->graph_voltagelow = p1->value().toFloat();
  }

  // Validate high is greater than low
  if (_mysettings->graph_voltagelow > _mysettings->graph_voltagehigh)
  {
    _mysettings->graph_voltagelow = 0;
  }

  if (request->hasParam("Language", true))
  {
    AsyncWebParameter *p1 = request->getParam("Language", true);
    p1->value().toCharArray(_mysettings->language, sizeof(_mysettings->language));
  }

  saveConfiguration();

  SendSuccess(request);
}

void DIYBMSServer::saveInfluxDBSetting(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("influxEnabled", true))
  {
    AsyncWebParameter *p1 = request->getParam("influxEnabled", true);
    _mysettings->influxdb_enabled = p1->value().equals("on") ? true : false;
  }
  else
  {
    _mysettings->influxdb_enabled = false;
  }

  if (request->hasParam("influxUrl", true))
  {
    AsyncWebParameter *p1 = request->getParam("influxUrl", true);
    p1->value().toCharArray(_mysettings->influxdb_serverurl, sizeof(_mysettings->influxdb_serverurl));
  }

  if (request->hasParam("influxDatabase", true))
  {
    AsyncWebParameter *p1 = request->getParam("influxDatabase", true);
    p1->value().toCharArray(_mysettings->influxdb_databasebucket, sizeof(_mysettings->influxdb_databasebucket));
  }

  if (request->hasParam("influxOrgId", true))
  {
    AsyncWebParameter *p1 = request->getParam("influxOrgId", true);
    p1->value().toCharArray(_mysettings->influxdb_orgid, sizeof(_mysettings->influxdb_orgid));
  }

  if (request->hasParam("influxToken", true))
  {
    AsyncWebParameter *p1 = request->getParam("influxToken", true);
    p1->value().toCharArray(_mysettings->influxdb_apitoken, sizeof(_mysettings->influxdb_apitoken));
  }

  saveConfiguration();

  // ConfigHasChanged = REBOOT_COUNT_DOWN;
  SendSuccess(request);
}

void DIYBMSServer::getvictron(AsyncWebServerRequest *request)
{
  AsyncResponseStream *response =
      request->beginResponseStream("application/json");

  DynamicJsonDocument doc(2048);
  JsonObject root = doc.to<JsonObject>();

  JsonObject settings = root.createNestedObject("victron");

  settings["enabled"] = _mysettings->VictronEnabled;

  JsonArray cvl = settings.createNestedArray("cvl");
  JsonArray ccl = settings.createNestedArray("ccl");
  JsonArray dcl = settings.createNestedArray("dcl");
  for (uint8_t i = 0; i < 3; i++)
  {
    cvl.add(_mysettings->cvl[i]);
    ccl.add(_mysettings->ccl[i]);
    dcl.add(_mysettings->dcl[i]);
  }

  response->addHeader("Cache-Control", "no-store");

  serializeJson(doc, *response);
  request->send(response);
}

void DIYBMSServer::saveVictron(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("VictronEnabled", true))
  {
    AsyncWebParameter *p1 = request->getParam("VictronEnabled", true);
    _mysettings->VictronEnabled = p1->value().equals("on") ? true : false;
  }
  else
  {
    _mysettings->VictronEnabled = false;
  }

  for (int i = 0; i < 3; i++)
  {
    String name = "cvl";
    name = name + i;
    if (request->hasParam(name.c_str(), true, false))
    {
      AsyncWebParameter *p1 = request->getParam(name.c_str(), true, false);
      _mysettings->cvl[i] = p1->value().toFloat() * 10;
    }

    name = "ccl";
    name = name + i;
    if (request->hasParam(name.c_str(), true, false))
    {
      AsyncWebParameter *p1 = request->getParam(name.c_str(), true, false);
      _mysettings->ccl[i] = p1->value().toFloat() * 10;
    }

    name = "dcl";
    name = name + i;
    if (request->hasParam(name.c_str(), true, false))
    {
      AsyncWebParameter *p1 = request->getParam(name.c_str(), true, false);
      _mysettings->dcl[i] = p1->value().toFloat() * 10;
    }
  }

  saveConfiguration();

  SendSuccess(request);
}

void DIYBMSServer::saveCurrentMonRelay(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  currentmonitoring_struct newvalues;
  // Set everything to zero/false
  memset(&newvalues, 0, sizeof(currentmonitoring_struct));

  if (request->hasParam("TempCompEnabled", true))
  {
    AsyncWebParameter *p1 = request->getParam("TempCompEnabled", true);
    newvalues.TempCompEnabled = p1->value().equals("on") ? true : false;
  }
  else
  {
    newvalues.TempCompEnabled = false;
  }

  if (request->hasParam("cmTMPOL", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmTMPOL", true);
    newvalues.RelayTriggerTemperatureOverLimit = p1->value().equals("on") ? true : false;
  }
  if (request->hasParam("cmCURROL", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmCURROL", true);
    newvalues.RelayTriggerCurrentOverLimit = p1->value().equals("on") ? true : false;
  }
  if (request->hasParam("cmCURRUL", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmCURRUL", true);
    newvalues.RelayTriggerCurrentUnderLimit = p1->value().equals("on") ? true : false;
  }
  if (request->hasParam("cmVOLTOL", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmVOLTOL", true);
    newvalues.RelayTriggerVoltageOverlimit = p1->value().equals("on") ? true : false;
  }
  if (request->hasParam("cmVOLTUL", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmVOLTUL", true);
    newvalues.RelayTriggerVoltageUnderlimit = p1->value().equals("on") ? true : false;
  }
  if (request->hasParam("cmPOL", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmPOL", true);
    newvalues.RelayTriggerPowerOverLimit = p1->value().equals("on") ? true : false;
  }

  CurrentMonitorSetRelaySettings(newvalues);

  SendSuccess(request);
}
void DIYBMSServer::saveCurrentMonAdvanced(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  currentmonitoring_struct newvalues;
  // Set everything to zero/false
  memset(&newvalues, 0, sizeof(currentmonitoring_struct));

  if (request->hasParam("cmcalibration", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmcalibration", true);
    newvalues.modbus.shuntcal = p1->value().toInt();
  }
  if (request->hasParam("cmtemplimit", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmtemplimit", true);
    newvalues.modbus.temperaturelimit = (int16_t)(p1->value().toInt());
  }
  if (request->hasParam("cmundervlimit", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmundervlimit", true);
    newvalues.modbus.undervoltagelimit = p1->value().toFloat();
  }
  if (request->hasParam("cmovervlimit", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmovervlimit", true);
    newvalues.modbus.overvoltagelimit = p1->value().toFloat();
  }
  if (request->hasParam("cmoverclimit", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmoverclimit", true);
    newvalues.modbus.overcurrentlimit = p1->value().toFloat();
  }
  if (request->hasParam("cmunderclimit", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmunderclimit", true);
    newvalues.modbus.undercurrentlimit = p1->value().toFloat();
  }
  if (request->hasParam("cmoverplimit", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmoverplimit", true);
    newvalues.modbus.overpowerlimit = p1->value().toFloat();
  }
  if (request->hasParam("cmtempcoeff", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmtempcoeff", true);
    newvalues.modbus.shunttempcoefficient = p1->value().toInt();
  }

  CurrentMonitorSetAdvancedSettings(newvalues);

  SendSuccess(request);
}

void DIYBMSServer::saveCurrentMonBasic(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("shuntmaxcur", true) && request->hasParam("shuntmv", true) && request->hasParam("cmbatterycapacity", true) && request->hasParam("cmfullchargevolt", true) && request->hasParam("cmtailcurrent", true) && request->hasParam("cmchargeefficiency", true))
  {
    AsyncWebParameter *p1 = request->getParam("shuntmaxcur", true);
    int shuntmaxcur = p1->value().toInt();

    AsyncWebParameter *p2 = request->getParam("shuntmv", true);
    int shuntmv = p2->value().toInt();

    AsyncWebParameter *p3 = request->getParam("cmbatterycapacity", true);
    uint16_t batterycapacity = (uint16_t)(p3->value().toInt());

    AsyncWebParameter *p4 = request->getParam("cmfullchargevolt", true);
    float fullchargevolt = p4->value().toFloat();

    AsyncWebParameter *p5 = request->getParam("cmtailcurrent", true);
    float tailcurrent = p5->value().toFloat();

    AsyncWebParameter *p6 = request->getParam("cmchargeefficiency", true);
    float chargeefficiency = p6->value().toFloat();

    CurrentMonitorSetBasicSettings(shuntmv, shuntmaxcur, batterycapacity, fullchargevolt, tailcurrent, chargeefficiency);
  }

  SendSuccess(request);
}

void DIYBMSServer::saveCurrentMonSettings(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("CurrentMonEnabled", true))
  {
    AsyncWebParameter *p1 = request->getParam("CurrentMonEnabled", true);
    _mysettings->currentMonitoringEnabled = p1->value().equals("on") ? true : false;
  }
  else
  {
    // If the parameter isn't there its FALSE/unchecked
    _mysettings->currentMonitoringEnabled = false;
  }

  if (request->hasParam("modbusAddress", true))
  {
    AsyncWebParameter *p1 = request->getParam("modbusAddress", true);
    _mysettings->currentMonitoringModBusAddress = p1->value().toInt();
  }

  if (_mysettings->currentMonitoringEnabled == false)
  {
    // Switch off current monitor, clear out the values
    memset(&currentMonitor, 0, sizeof(currentmonitoring_struct));
    currentMonitor.validReadings = false;
  }

  saveConfiguration();

  SendSuccess(request);
}

void DIYBMSServer::saveRS485Settings(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("rs485baudrate", true))
  {
    AsyncWebParameter *p1 = request->getParam("rs485baudrate", true);
    _mysettings->rs485baudrate = p1->value().toInt();
  }

  if (request->hasParam("rs485databit", true))
  {
    AsyncWebParameter *p1 = request->getParam("rs485databit", true);
    _mysettings->rs485databits = (uart_word_length_t)(p1->value().toInt());
  }

  if (request->hasParam("rs485parity", true))
  {
    AsyncWebParameter *p1 = request->getParam("rs485parity", true);
    _mysettings->rs485parity = (uart_parity_t)(p1->value().toInt());
  }

  if (request->hasParam("rs485stopbit", true))
  {
    AsyncWebParameter *p1 = request->getParam("rs485stopbit", true);
    _mysettings->rs485stopbits = (uart_stop_bits_t)(p1->value().toInt());
  }

  saveConfiguration();

  ConfigureRS485();
  SendSuccess(request);
}

void DIYBMSServer::saveRuleConfiguration(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  // relaytype
  for (int i = 0; i < RELAY_TOTAL; i++)
  {
    String name = "relaytype";
    name = name + (i + 1);
    if (request->hasParam(name.c_str(), true, false))
    {
      AsyncWebParameter *p1 = request->getParam(name.c_str(), true, false);
      // Default
      RelayType oldValue = _mysettings->relaytype[i];
      if (p1->value().equals("Pulse"))
      {
        _mysettings->relaytype[i] = RelayType::RELAY_PULSE;
      }
      else
      {
        _mysettings->relaytype[i] = RelayType::RELAY_STANDARD;
      }

      if (oldValue != _mysettings->relaytype[i])
      {
        // The type of relay has changed - we probably need to reset something here
        ESP_LOGI(TAG, "Type of relay has changed");
        previousRelayState[i] = RelayState::RELAY_X;
      }
    }
  }

  // Relay default
  for (int i = 0; i < RELAY_TOTAL; i++)
  {
    String name = "defaultrelay";
    name = name + (i + 1);
    if (request->hasParam(name.c_str(), true, false))
    {
      AsyncWebParameter *p1 = request->getParam(name.c_str(), true, false);
      // Default
      _mysettings->rulerelaydefault[i] = RelayState::RELAY_OFF;
      if (p1->value().equals("On"))
      {
        _mysettings->rulerelaydefault[i] = RelayState::RELAY_ON;
      }
    }
  }

  for (int rule = 0; rule < RELAY_RULES; rule++)
  {

    // TODO: This STRING doesnt work properly if its on a single line!
    String name = "rule";
    name = name + (rule);
    name = name + "value";

    if (request->hasParam(name, true))
    {
      AsyncWebParameter *p1 = request->getParam(name, true);
      _mysettings->rulevalue[rule] = p1->value().toInt();
    }

    // TODO: This STRING doesnt work properly if its on a single line!
    String hname = "rule";
    hname = hname + (rule);
    hname = hname + "hysteresis";
    if (request->hasParam(hname, true))
    {
      AsyncWebParameter *p1 = request->getParam(hname, true);
      _mysettings->rulehysteresis[rule] = p1->value().toInt();
    }

    // Rule/relay processing
    for (int i = 0; i < RELAY_TOTAL; i++)
    {
      // TODO: This STRING doesnt work properly if its on a single line!
      String name = "rule";
      name = name + (rule);
      name = name + "relay";
      name = name + (i + 1);
      if (request->hasParam(name, true))
      {
        AsyncWebParameter *p1 = request->getParam(name, true);
        _mysettings->rulerelaystate[rule][i] = p1->value().equals("X") ? RELAY_X : p1->value().equals("On") ? RelayState::RELAY_ON
                                                                                                            : RelayState::RELAY_OFF;
      }
    }

    // Reset state of rules after updating the new values
    for (int8_t r = 0; r < RELAY_RULES; r++)
    {
      _rules->rule_outcome[r] = false;
    }
  }

  saveConfiguration();

  SendSuccess(request);
}

void DIYBMSServer::saveStorage(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("loggingEnabled", true))
  {
    AsyncWebParameter *p1 = request->getParam("loggingEnabled", true);
    _mysettings->loggingEnabled = p1->value().equals("on") ? true : false;
  }
  else
  {
    // Switch off logging
    _mysettings->loggingEnabled = false;
  }

  if (request->hasParam("loggingFreq", true))
  {
    AsyncWebParameter *p1 = request->getParam("loggingFreq", true);
    _mysettings->loggingFrequencySeconds = p1->value().toInt();
    // Validate
    if (_mysettings->loggingFrequencySeconds < 15 || _mysettings->loggingFrequencySeconds > 600)
    {
      _mysettings->loggingFrequencySeconds = 15;
    }
  }

  saveConfiguration();

  SendSuccess(request);
}

void DIYBMSServer::saveNTP(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("NTPServer", true))
  {
    AsyncWebParameter *p1 = request->getParam("NTPServer", true);
    p1->value().toCharArray(_mysettings->ntpServer, sizeof(_mysettings->ntpServer));
  }

  if (request->hasParam("NTPZoneHour", true))
  {
    AsyncWebParameter *p1 = request->getParam("NTPZoneHour", true);
    _mysettings->timeZone = p1->value().toInt();
  }

  if (request->hasParam("NTPZoneMin", true))
  {
    AsyncWebParameter *p1 = request->getParam("NTPZoneMin", true);
    _mysettings->minutesTimeZone = p1->value().toInt();
  }

  _mysettings->daylight = false;
  if (request->hasParam("NTPDST", true))
  {
    AsyncWebParameter *p1 = request->getParam("NTPDST", true);
    _mysettings->daylight = p1->value().equals("on") ? true : false;
  }
  else
  {
    _mysettings->daylight = false;
  }

  saveConfiguration();

  // ConfigHasChanged = REBOOT_COUNT_DOWN;
  SendSuccess(request);
}

void DIYBMSServer::saveBankConfiguration(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  uint8_t totalSeriesModules = 1;
  uint8_t totalBanks = 1;
  uint16_t baudrate = COMMS_BAUD_RATE;

  if (request->hasParam("totalSeriesModules", true))
  {
    AsyncWebParameter *p1 = request->getParam("totalSeriesModules", true);
    totalSeriesModules = p1->value().toInt();
  }

  if (request->hasParam("totalBanks", true))
  {
    AsyncWebParameter *p1 = request->getParam("totalBanks", true);
    totalBanks = p1->value().toInt();
  }

  if (request->hasParam("baudrate", true))
  {
    AsyncWebParameter *p1 = request->getParam("baudrate", true);
    baudrate = p1->value().toInt();
  }

  if (totalSeriesModules * totalBanks <= maximum_controller_cell_modules)
  {
    _mysettings->totalNumberOfSeriesModules = totalSeriesModules;
    _mysettings->totalNumberOfBanks = totalBanks;
    _mysettings->baudRate = baudrate;
    saveConfiguration();

    SendSuccess(request);
  }
  else
  {
    SendFailure(request);
  }
}

void DIYBMSServer::saveMQTTSetting(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("mqttEnabled", true))
  {
    AsyncWebParameter *p1 = request->getParam("mqttEnabled", true);
    _mysettings->mqtt_enabled = p1->value().equals("on") ? true : false;
  }
  else
  {
    _mysettings->mqtt_enabled = false;
  }

  if (request->hasParam("mqttTopic", true))
  {
    AsyncWebParameter *p1 = request->getParam("mqttTopic", true);
    p1->value().toCharArray(_mysettings->mqtt_topic, sizeof(_mysettings->mqtt_topic));
  }
  else
  {
    strcpy(_mysettings->mqtt_topic, "diybms");
  }

  if (request->hasParam("mqttPort", true))
  {
    AsyncWebParameter *p1 = request->getParam("mqttPort", true);
    _mysettings->mqtt_port = p1->value().toInt();
  }

  if (request->hasParam("mqttServer", true))
  {
    AsyncWebParameter *p1 = request->getParam("mqttServer", true);
    p1->value().toCharArray(_mysettings->mqtt_server, sizeof(_mysettings->mqtt_server));
  }

  if (request->hasParam("mqttUsername", true))
  {
    AsyncWebParameter *p1 = request->getParam("mqttUsername", true);
    p1->value().toCharArray(_mysettings->mqtt_username, sizeof(_mysettings->mqtt_username));
  }

  if (request->hasParam("mqttPassword", true))
  {
    AsyncWebParameter *p1 = request->getParam("mqttPassword", true);
    p1->value().toCharArray(_mysettings->mqtt_password, sizeof(_mysettings->mqtt_password));
  }

  saveConfiguration();

  SendSuccess(request);
}

void DIYBMSServer::saveGlobalSetting(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("BypassOverTempShutdown", true) && request->hasParam("BypassThresholdmV", true))
  {

    AsyncWebParameter *p1 = request->getParam("BypassOverTempShutdown", true);
    _mysettings->BypassOverTempShutdown = p1->value().toInt();

    AsyncWebParameter *p2 = request->getParam("BypassThresholdmV", true);
    _mysettings->BypassThresholdmV = p2->value().toInt();

    if (_prg->sendSaveGlobalSetting(_mysettings->BypassThresholdmV, _mysettings->BypassOverTempShutdown))
    {
      saveConfiguration();

      uint8_t totalModules = _mysettings->totalNumberOfBanks * _mysettings->totalNumberOfSeriesModules;

      for (uint8_t i = 0; i < totalModules; i++)
      {
        if (cmi[i].valid)
        {
          cmi[i].BypassThresholdmV = _mysettings->BypassThresholdmV;
          cmi[i].BypassOverTempShutdown = _mysettings->BypassOverTempShutdown;
        }
      }

      // Just returns NULL
      SendSuccess(request);
    }
    else
    {
      SendFailure(request);
    }
  }
  else
  {
    request->send(500, "text/plain", "Missing parameters");
  }
}

void DIYBMSServer::handleNotFound(AsyncWebServerRequest *request)
{
  request->send(404, "text/plain", "Not found");
}

void DIYBMSServer::saveSetting(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("m", true))
  {
    AsyncWebParameter *module = request->getParam("m", true);
    // Will this overflow?
    uint8_t m = module->value().toInt();

    if (m > maximum_controller_cell_modules)
    {
      request->send(500, "text/plain", "Wrong parameters");
    }
    else
    {

      uint8_t BypassOverTempShutdown = 0xFF;
      uint16_t BypassThresholdmV = 0xFFFF;

      // Resistance of bypass load
      // float LoadResistance = 0xFFFF;
      // Voltage Calibration
      float Calibration = 0xFFFF;
      // Reference voltage (millivolt) normally 2.00mV
      // float mVPerADC = 0xFFFF;
      // Internal Thermistor settings
      // uint16_t Internal_BCoefficient = 0xFFFF;
      // External Thermistor settings
      // uint16_t External_BCoefficient = 0xFFFF;

      if (request->hasParam("BypassOverTempShutdown", true))
      {
        AsyncWebParameter *p1 = request->getParam("BypassOverTempShutdown", true);
        BypassOverTempShutdown = p1->value().toInt();
      }

      if (request->hasParam("BypassThresholdmV", true))
      {
        AsyncWebParameter *p1 = request->getParam("BypassThresholdmV", true);
        BypassThresholdmV = p1->value().toInt();
      }
      if (request->hasParam("Calib", true))
      {
        AsyncWebParameter *p1 = request->getParam("Calib", true);
        Calibration = p1->value().toFloat();
      }

      _prg->sendSaveSetting(m, BypassThresholdmV, BypassOverTempShutdown, Calibration);

      clearModuleValues(m);

      SendSuccess(request);
    }
  }
  else
  {
    request->send(500, "text/plain", "Missing parameters");
  }
}

void DIYBMSServer::clearModuleValues(uint8_t module)
{
  cmi[module].valid = false;
  cmi[module].voltagemV = 0;
  cmi[module].voltagemVMin = 6000;
  cmi[module].voltagemVMax = 0;
  cmi[module].badPacketCount = 0;
  cmi[module].inBypass = false;
  cmi[module].bypassOverTemp = false;
  cmi[module].internalTemp = -40;
  cmi[module].externalTemp = -40;
}

void DIYBMSServer::GetRules(AsyncWebServerRequest *request)
{
  AsyncResponseStream *response =
      request->beginResponseStream("application/json");

  DynamicJsonDocument doc(4096);
  JsonObject root = doc.to<JsonObject>();

  struct tm timeinfo;
  if (!getLocalTime(&timeinfo, 100))
  {
    root["timenow"] = 0;
  }
  else
  {
    root["timenow"] = (timeinfo.tm_hour * 60) + timeinfo.tm_min;
  }

  root["ControlState"] = (*_controlState);

  JsonArray defaultArray = root.createNestedArray("relaydefault");
  for (uint8_t relay = 0; relay < RELAY_TOTAL; relay++)
  {
    switch (_mysettings->rulerelaydefault[relay])
    {
    case RELAY_OFF:
      defaultArray.add(false);
      break;
    case RELAY_ON:
      defaultArray.add(true);
      break;
    default:
      defaultArray.add((char *)0);
      break;
    }
  }

  JsonArray typeArray = root.createNestedArray("relaytype");
  for (uint8_t relay = 0; relay < RELAY_TOTAL; relay++)
  {
    switch (_mysettings->relaytype[relay])
    {
    case RELAY_STANDARD:
      typeArray.add("Std");
      break;
    case RELAY_PULSE:
      typeArray.add("Pulse");
      break;
    default:
      typeArray.add((char *)0);
      break;
    }
  }

  JsonArray bankArray = root.createNestedArray("rules");

  for (uint8_t r = 0; r < RELAY_RULES; r++)
  {
    JsonObject rule = bankArray.createNestedObject();
    rule["value"] = _mysettings->rulevalue[r];
    rule["hysteresis"] = _mysettings->rulehysteresis[r];
    rule["triggered"] = _rules->rule_outcome[r];
    JsonArray data = rule.createNestedArray("relays");

    for (uint8_t relay = 0; relay < RELAY_TOTAL; relay++)
    {
      switch (_mysettings->rulerelaystate[r][relay])
      {
      case RELAY_OFF:
        data.add(false);
        break;
      case RELAY_ON:
        data.add(true);
        break;
      default:
        data.add((char *)0);
        break;
      }
    }
  }

  serializeJson(doc, *response);
  request->send(response);
}

void DIYBMSServer::settings(AsyncWebServerRequest *request)
{
  AsyncResponseStream *response =
      request->beginResponseStream("application/json");

  DynamicJsonDocument doc(2048);
  JsonObject root = doc.to<JsonObject>();

  JsonObject settings = root.createNestedObject("settings");

  // settings["Version"] = String(GIT_VERSION);
  // settings["CompileDate"] = String(COMPILE_DATE_TIME);

  settings["totalnumberofbanks"] = _mysettings->totalNumberOfBanks;
  settings["totalseriesmodules"] = _mysettings->totalNumberOfSeriesModules;
  settings["baudrate"] = _mysettings->baudRate;

  settings["bypassthreshold"] = _mysettings->BypassThresholdmV;
  settings["bypassovertemp"] = _mysettings->BypassOverTempShutdown;

  settings["NTPServerName"] = _mysettings->ntpServer;
  settings["TimeZone"] = _mysettings->timeZone;
  settings["MinutesTimeZone"] = _mysettings->minutesTimeZone;
  settings["DST"] = _mysettings->daylight;

  settings["FreeHeap"] = ESP.getFreeHeap();
  settings["MinFreeHeap"] = ESP.getMinFreeHeap();
  settings["HeapSize"] = ESP.getHeapSize();
  settings["SdkVersion"] = ESP.getSdkVersion();

  settings["HostName"] = WiFi.getHostname();

  time_t now;
  if (time(&now))
  {
    settings["now"] = now;
  }

  response->addHeader("Cache-Control", "no-store");

  serializeJson(doc, *response);
  request->send(response);
}

void DIYBMSServer::fileSystemListDirectory(AsyncResponseStream *response, fs::FS &fs, const char *dirname, uint8_t levels)
{

  File root = fs.open(dirname);
  if (!root)
  {
    ESP_LOGE(TAG, "failed to open dir");
    return;
  }
  if (!root.isDirectory())
  {
    ESP_LOGE(TAG, "not a dir");
    return;
  }

  File file = root.openNextFile();
  while (file)
  {
    if (file.isDirectory())
    {
      // Hide the diybms folder where the config files are kept
      if (levels && String(file.name()).startsWith("/diybms") == false)
      {
        fileSystemListDirectory(response, fs, file.name(), levels - 1);
        response->print(',');
      }
    }
    else
    {
      response->print('\"');
      response->print(file.name());
      response->print('\"');

      response->print(',');
    }

    file = root.openNextFile();
  }

  // Trailing null to cope with trailing ','
  response->print("null");
}

void DIYBMSServer::rs485settings(AsyncWebServerRequest *request)
{
  AsyncResponseStream *response = request->beginResponseStream("application/json");
  response->print("{");

  response->print("\"baudrate\":");
  response->print(_mysettings->rs485baudrate);

  response->print(",\"databits\":");
  response->print(_mysettings->rs485databits);

  response->print(",\"parity\":");
  response->print(_mysettings->rs485parity);

  response->print(",\"stopbits\":");
  response->print(_mysettings->rs485stopbits);

  // The END...
  response->print('}');

  response->addHeader("Cache-Control", "no-store");
  request->send(response);
}

void DIYBMSServer::currentmonitor(AsyncWebServerRequest *request)
{
  AsyncResponseStream *response = request->beginResponseStream("application/json");
  response->print("{");

  PrintStreamCommaBoolean(response, "\"enabled\":", _mysettings->currentMonitoringEnabled);
  PrintStreamComma(response, "\"address\":", _mysettings->currentMonitoringModBusAddress);

  // Convert to milliseconds
  uint32_t x = 0;
  if (currentMonitor.validReadings)
  {
    x = (esp_timer_get_time() - currentMonitor.timestamp) / 1000;
  }
  PrintStreamComma(response, "\"timestampage\":", x);
  PrintStreamCommaBoolean(response, "\"valid\":", currentMonitor.validReadings);

  PrintStreamComma(response, "\"batterycapacity\":", currentMonitor.modbus.batterycapacityamphour);
  PrintStreamCommaFloat(response, "\"tailcurrent\":", currentMonitor.modbus.tailcurrentamps);
  PrintStreamCommaFloat(response, "\"fullchargevolt\":", currentMonitor.modbus.fullychargedvoltage);
  PrintStreamCommaFloat(response, "\"chargeefficiency\":", currentMonitor.chargeefficiency);

  PrintStreamCommaFloat(response, "\"voltage\":", currentMonitor.modbus.voltage);
  PrintStreamCommaFloat(response, "\"current\":", currentMonitor.modbus.current);
  PrintStreamComma(response, "\"mahout\":", currentMonitor.modbus.milliamphour_out);
  PrintStreamComma(response, "\"mahin\":", currentMonitor.modbus.milliamphour_in);
  PrintStreamCommaInt16(response, "\"temperature\":", currentMonitor.modbus.temperature);
  PrintStreamComma(response, "\"watchdog\":", currentMonitor.modbus.watchdogcounter);
  PrintStreamCommaFloat(response, "\"power\":", currentMonitor.modbus.power);
  PrintStreamCommaFloat(response, "\"actualshuntmv\":", currentMonitor.modbus.shuntmV);
  PrintStreamCommaFloat(response, "\"currentlsb\":", currentMonitor.modbus.currentlsb);
  PrintStreamCommaFloat(response, "\"resistance\":", currentMonitor.modbus.shuntresistance);
  PrintStreamComma(response, "\"calibration\":", currentMonitor.modbus.shuntcal);
  PrintStreamCommaInt16(response, "\"templimit\":", currentMonitor.modbus.temperaturelimit);
  PrintStreamCommaFloat(response, "\"undervlimit\":", currentMonitor.modbus.undervoltagelimit);
  PrintStreamCommaFloat(response, "\"overvlimit\":", currentMonitor.modbus.overvoltagelimit);
  PrintStreamCommaFloat(response, "\"overclimit\":", currentMonitor.modbus.overcurrentlimit);
  PrintStreamCommaFloat(response, "\"underclimit\":", currentMonitor.modbus.undercurrentlimit);
  PrintStreamCommaFloat(response, "\"overplimit\":", currentMonitor.modbus.overpowerlimit);
  PrintStreamComma(response, "\"tempcoeff\":", currentMonitor.modbus.shunttempcoefficient);
  PrintStreamComma(response, "\"model\":", currentMonitor.modbus.modelnumber);

  PrintStreamComma(response, "\"firmwarev\":", currentMonitor.modbus.firmwareversion);
  PrintStreamComma(response, "\"firmwaredate\":", currentMonitor.modbus.firmwaredatetime);

  // Boolean flag values
  PrintStreamCommaBoolean(response, "\"TMPOL\":", currentMonitor.TemperatureOverLimit);
  PrintStreamCommaBoolean(response, "\"CURROL\":", currentMonitor.CurrentOverLimit);
  PrintStreamCommaBoolean(response, "\"CURRUL\":", currentMonitor.CurrentUnderLimit);
  PrintStreamCommaBoolean(response, "\"VOLTOL\":", currentMonitor.VoltageOverlimit);
  PrintStreamCommaBoolean(response, "\"VOLTUL\":", currentMonitor.VoltageUnderlimit);
  PrintStreamCommaBoolean(response, "\"POL\":", currentMonitor.PowerOverLimit);
  PrintStreamCommaBoolean(response, "\"TempCompEnabled\":", currentMonitor.TempCompEnabled);
  PrintStreamCommaBoolean(response, "\"ADCRange4096mV\":", currentMonitor.ADCRange4096mV);

  // Trigger values
  PrintStreamCommaBoolean(response, "\"T_TMPOL\":", currentMonitor.RelayTriggerTemperatureOverLimit);
  PrintStreamCommaBoolean(response, "\"T_CURROL\":", currentMonitor.RelayTriggerCurrentOverLimit);
  PrintStreamCommaBoolean(response, "\"T_CURRUL\":", currentMonitor.RelayTriggerCurrentUnderLimit);
  PrintStreamCommaBoolean(response, "\"T_VOLTOL\":", currentMonitor.RelayTriggerVoltageOverlimit);
  PrintStreamCommaBoolean(response, "\"T_VOLTUL\":", currentMonitor.RelayTriggerVoltageUnderlimit);
  PrintStreamCommaBoolean(response, "\"T_POL\":", currentMonitor.RelayTriggerPowerOverLimit);
  PrintStreamCommaBoolean(response, "\"RelayState\":", currentMonitor.RelayState);

  PrintStreamComma(response, "\"shuntmv\":", currentMonitor.modbus.shuntmillivolt);
  PrintStream(response, "\"shuntmaxcur\":", currentMonitor.modbus.shuntmaxcurrent);

  // The END...
  response->print('}');

  response->addHeader("Cache-Control", "no-store");
  request->send(response);
}

void DIYBMSServer::avrstorage(AsyncWebServerRequest *request)
{
  AsyncResponseStream *response = request->beginResponseStream("application/json");

  //{"avrprog":{"avrprog":[{"board":"V400","efuse":"F4","hfuse":"D6","lfuse":"62","mcu":"1e9315","name":"fw_V400_ca58bde0.bin","ver":"ca58bde0"},{"board":"V410","efuse":"F4","hfuse":"D6","lfuse":"62","mcu":"1e9315","name":"fw_V410_ca58bde0.bin","ver":"ca58bde0"},{"board":"V420","efuse":"F4","hfuse":"D6","lfuse":"62","mcu":"1e9315","name":"fw_V420_ca58bde0.bin","ver":"ca58bde0"},{"board":"V420_SWAPR19R20","efuse":"F4","hfuse":"D6","lfuse":"62","mcu":"1e9315","name":"fw_V420_SWAPR19R20_ca58bde0.bin","ver":"ca58bde0"},{"board":"V421","efuse":"F4","hfuse":"D6","lfuse":"62","mcu":"1e9315","name":"fw_V421_ca58bde0.bin","ver":"ca58bde0"},{"board":"V421_LTO","efuse":"F4","hfuse":"D6","lfuse":"62","mcu":"1e9315","name":"fw_V421_LTO_ca58bde0.bin","ver":"ca58bde0"}]}}
  // See if we can open and process the AVR PROGRAMMER manifest file
  response->print("{");
  response->print("\"ProgModeEnabled\":");
  response->print(_avrsettings.programmingModeEnabled ? "1" : "0");
  response->print(",\"InProgress\":");
  response->print(_avrsettings.inProgress ? "1" : "0");
  response->print(",\"avrprog\":");
  String manifest = String("/avr/manifest.json");
  if (LITTLEFS.exists(manifest))
  {
    StaticJsonDocument<3000> doc;
    File file = LITTLEFS.open(manifest);
    DeserializationError error = deserializeJson(doc, file);
    if (error)
    {
      ESP_LOGE(TAG, "Error deserialize Json");
      response->print("{}");
    }
    else
    {
      serializeJson(doc, *response);
    }
    file.close();
  }
  else
  {
    // No files!
    response->print("{}");
  }

  // The END...
  response->print('}');

  response->addHeader("Cache-Control", "no-store");
  request->send(response);
}

void DIYBMSServer::storage(AsyncWebServerRequest *request)
{
  sdcard_info info;

  info.available = _sd_card_installed;

  // Lock VSPI bus during operation (not sure if this is acutally needed, as the SD class may have cached these values)
  if (_hal->GetVSPIMutex())
  {
    // Convert to KiB
    info.totalkilobytes = SD.totalBytes() / 1024;
    info.usedkilobytes = SD.usedBytes() / 1024;
    _hal->ReleaseVSPIMutex();
  }
  else
  {
    info.totalkilobytes = 0;
    info.usedkilobytes = 0;
  }

  info.flash_totalkilobytes = LITTLEFS.totalBytes() / 1024;
  info.flash_usedkilobytes = LITTLEFS.usedBytes() / 1024;

  AsyncResponseStream *response = request->beginResponseStream("application/json");

  response->print("{\"storage\":{");
  PrintStreamCommaBoolean(response, "\"logging\":", _mysettings->loggingEnabled);
  PrintStreamComma(response, "\"frequency\":", _mysettings->loggingFrequencySeconds);

  response->print("\"sdcard\":{");
  PrintStreamCommaBoolean(response, "\"available\":", info.available);
  PrintStreamComma(response, "\"total\":", info.totalkilobytes);
  PrintStreamComma(response, "\"used\":", info.usedkilobytes);
  response->print("\"files\":[");
  // File listing goes here
  if (info.available)
  {
    if (_hal->GetVSPIMutex())
    {
      fileSystemListDirectory(response, SD, "/", 2);
      _hal->ReleaseVSPIMutex();
    }
  }
  response->print(']');

  response->print("},\"flash\":{");
  PrintStreamComma(response, "\"total\":", info.flash_totalkilobytes);
  PrintStreamComma(response, "\"used\":", info.flash_usedkilobytes);

  response->print("\"files\":[");
  fileSystemListDirectory(response, LITTLEFS, "/", 0);
  response->print(']');
  response->print("}");

  // The END...
  response->print('}');
  response->print('}');

  response->addHeader("Cache-Control", "no-store");
  request->send(response);
}

void DIYBMSServer::integration(AsyncWebServerRequest *request)
{
  AsyncResponseStream *response =
      request->beginResponseStream("application/json");

  DynamicJsonDocument doc(2048);
  JsonObject root = doc.to<JsonObject>();

  JsonObject mqtt = root.createNestedObject("mqtt");
  mqtt["enabled"] = _mysettings->mqtt_enabled;
  mqtt["topic"] = _mysettings->mqtt_topic;
  mqtt["port"] = _mysettings->mqtt_port;
  mqtt["server"] = _mysettings->mqtt_server;
  mqtt["username"] = _mysettings->mqtt_username;
  // We don't output the password in the json file as this could breach security
  // mqtt["password"] =_mysettings->mqtt_password;

  JsonObject influxdb = root.createNestedObject("influxdb");
  influxdb["enabled"] = _mysettings->influxdb_enabled;
  influxdb["url"] = _mysettings->influxdb_serverurl;
  influxdb["bucket"] = _mysettings->influxdb_databasebucket;
  influxdb["apitoken"] = _mysettings->influxdb_apitoken;
  influxdb["orgid"] = _mysettings->influxdb_orgid;

  serializeJson(doc, *response);
  request->send(response);
}

void DIYBMSServer::identifyModule(AsyncWebServerRequest *request)
{
  if (request->hasParam("c", false))
  {
    AsyncWebParameter *cellid = request->getParam("c", false);
    uint8_t c = cellid->value().toInt();

    if (c > _mysettings->totalNumberOfBanks * _mysettings->totalNumberOfSeriesModules)
    {
      request->send(500, "text/plain", "Wrong parameter bank");
      return;
    }
    else
    {
      _prg->sendIdentifyModuleRequest(c);
      SendSuccess(request);
    }
  }
  else
  {
    request->send(500, "text/plain", "Missing parameters");
  }
}

void DIYBMSServer::downloadFile(AsyncWebServerRequest *request)
{
  if (request->hasParam("type", false) && request->hasParam("file", false))
  {
    String type = request->getParam("type", false)->value();
    String file = request->getParam("file", false)->value();

    // Do some really simple validation here to prevent files being downloaded,
    // which could be a security risk.
    // See: directory traversal vulnerability

    if (file.startsWith("/") == false)
    {
      // All file names must start at the root
      request->send(400); // 400 bad request
      return;
    }

    if (file.startsWith("//") == true)
    {
      // All file names must start at the root
      request->send(400); // 400 bad request
      return;
    }

    if (file.startsWith("/diybms/") == true)
    {
      // Prevent downloads from /diybms/ folder
      request->send(401); // 401 Unauthorized
      return;
    }

    if (type.equals("sdcard") && _sd_card_installed)
    {
      // Process file from SD card

      if (_hal->GetVSPIMutex())
      {
        // Get the file
        ESP_LOGI(TAG, "Download SDCard file %s", file.c_str());

        request->send(*_sdcard, file, "application/octet-stream", true, nullptr);
        _hal->ReleaseVSPIMutex();
        return;
      }
    }

    if (type.equals("flash"))
    {
      // Process file from flash storage
      ESP_LOGI(TAG, "Download FLASH file %s", file.c_str());
      request->send(LITTLEFS, file, "application/octet-stream", true, nullptr);
      return;
    }
  }

  request->send(400); // 400 bad request
}

void DIYBMSServer::modules(AsyncWebServerRequest *request)
{
  if (request->hasParam("c", false))
  {
    AsyncWebParameter *cellid = request->getParam("c", false);
    uint8_t c = cellid->value().toInt();

    if (c > _mysettings->totalNumberOfBanks * _mysettings->totalNumberOfSeriesModules)
    {
      request->send(500, "text/plain", "Wrong parameter bank");
      return;
    }

    if (cmi[c].settingsCached == false)
    {
      _prg->sendGetSettingsRequest(c);
    }

    AsyncResponseStream *response = request->beginResponseStream("application/json");

    DynamicJsonDocument doc(2048);
    JsonObject root = doc.to<JsonObject>();
    JsonObject settings = root.createNestedObject("settings");

    uint8_t b = c / _mysettings->totalNumberOfSeriesModules;
    uint8_t m = c - (b * _mysettings->totalNumberOfSeriesModules);
    settings["bank"] = b;
    settings["module"] = m;
    settings["id"] = c;
    settings["ver"] = cmi[c].BoardVersionNumber;
    settings["code"] = cmi[c].CodeVersionNumber;
    settings["Cached"] = cmi[c].settingsCached;

    if (cmi[c].settingsCached)
    {
      settings["BypassOverTempShutdown"] = cmi[c].BypassOverTempShutdown;
      settings["BypassThresholdmV"] = cmi[c].BypassThresholdmV;
      settings["LoadRes"] = cmi[c].LoadResistance;
      settings["Calib"] = cmi[c].Calibration;
      settings["mVPerADC"] = cmi[c].mVPerADC;
      settings["IntBCoef"] = cmi[c].Internal_BCoefficient;
      settings["ExtBCoef"] = cmi[c].External_BCoefficient;
    }

    serializeJson(doc, *response);
    request->send(response);
  }
}

/*
Restart controller from web interface
*/
void DIYBMSServer::handleRestartController(AsyncWebServerRequest *request)
{
  ESP.restart();
}

void DIYBMSServer::monitor3(AsyncWebServerRequest *request)
{
  // DynamicJsonDocument doc(maximum_controller_cell_modules * 50);
  AsyncResponseStream *response = request->beginResponseStream("application/json");

  uint8_t totalModules = _mysettings->totalNumberOfBanks * _mysettings->totalNumberOfSeriesModules;
  uint8_t comma = totalModules - 1;

  response->print("{\"badpacket\":[");

  for (uint8_t i = 0; i < totalModules; i++)
  {
    if (cmi[i].valid)
    {
      response->print(cmi[i].badPacketCount);
    }
    else
    {
      // Return NULL
      response->print("null");
    }
    if (i < comma)
    {
      response->print(',');
    }
  }

  response->print("],\"balcurrent\":[");

  for (uint8_t i = 0; i < totalModules; i++)
  {
    if (cmi[i].valid)
    {
      response->print(cmi[i].BalanceCurrentCount);
    }
    else
    {
      // Return NULL
      response->print("null");
    }
    if (i < comma)
    {
      response->print(',');
    }
  }

  response->print("],\"pktrecvd\":[");

  for (uint8_t i = 0; i < totalModules; i++)
  {
    if (cmi[i].valid)
    {
      response->print(cmi[i].PacketReceivedCount);
    }
    else
    {
      // Return NULL
      response->print("null");
    }
    if (i < comma)
    {
      response->print(',');
    }
  }
  response->print("]}");

  response->addHeader("Cache-Control", "no-store");
  request->send(response);
}

void DIYBMSServer::PrintStreamCommaBoolean(AsyncResponseStream *response, const char *text, bool boolean)
{
  response->print(text);
  if (boolean)
  {
    response->print("true");
  }
  else
  {
    response->print("false");
  }
  response->print(',');
}

void DIYBMSServer::PrintStreamCommaFloat(AsyncResponseStream *response, const char *text, float value)
{
  response->print(text);
  // Print value to 6 decimal places
  response->print(value, 6);
  response->print(',');
}

void DIYBMSServer::PrintStreamComma(AsyncResponseStream *response, const char *text, uint32_t value)
{
  response->print(text);
  response->print(value);
  response->print(',');
}

void DIYBMSServer::PrintStreamCommaInt16(AsyncResponseStream *response, const char *text, int16_t value)
{
  response->print(text);
  response->print(value);
  response->print(',');
}

void DIYBMSServer::PrintStream(AsyncResponseStream *response, const char *text, uint32_t value)
{
  response->print(text);
  response->print(value);
}
void DIYBMSServer::monitor2(AsyncWebServerRequest *request)
{
  uint8_t totalModules = _mysettings->totalNumberOfBanks * _mysettings->totalNumberOfSeriesModules;
  const char comma = ',';
  const char *null = "null";
  AsyncResponseStream *response = request->beginResponseStream("application/json");

  PrintStreamComma(response, "{\"banks\":", _mysettings->totalNumberOfBanks);
  PrintStreamComma(response, "\"seriesmodules\":", _mysettings->totalNumberOfSeriesModules);
  PrintStreamComma(response, "\"sent\":", _prg->packetsGenerated);
  PrintStreamComma(response, "\"received\":", _receiveProc->packetsReceived);
  PrintStreamComma(response, "\"modulesfnd\":", _receiveProc->totalModulesFound);
  PrintStreamComma(response, "\"badcrc\":", _receiveProc->totalCRCErrors);
  PrintStreamComma(response, "\"ignored\":", _receiveProc->totalNotProcessedErrors);
  PrintStreamComma(response, "\"roundtrip\":", _receiveProc->packetTimerMillisecond);
  PrintStreamComma(response, "\"oos\":", _receiveProc->totalOutofSequenceErrors);
  PrintStreamComma(response, "\"qlen\":", _prg->queueLength());

  PrintStreamComma(response, "\"activerules\":", _rules->active_rule_count);
  PrintStreamComma(response, "\"uptime\":", (uint32_t)(esp_timer_get_time() / (uint64_t)1e+6));

  PrintStreamComma(response, "\"can_fail\":", canbus_messages_failed_sent);
  PrintStreamComma(response, "\"can_sent\":", canbus_messages_sent);
  PrintStreamComma(response, "\"can_rec\":", canbus_messages_received);

  // Output last 2 charaters from security cookie, to allow browser to detect when its
  // no longer in sync with the back end and report warning.
  // Technically this downgrades the complexity of the XSS key, as it reduces key length.
  response->print("\"sec\":\"");
  response->print(UUIDStringLast2Chars);
  response->print("\",");

  response->print(F("\"errors\":["));
  uint8_t count = 0;

  for (size_t i = 0; i < sizeof(_rules->ErrorCodes); i++)
  {
    if (_rules->ErrorCodes[i] != InternalErrorCode::NoError)
    {
      // Comma if not zero
      if (count)
      {
        response->print(comma);
      }

      response->print(_rules->ErrorCodes[i]);
      count++;
    }
  }
  response->print("],");

  response->print(F("\"warnings\":["));
  count = 0;
  for (size_t i = 0; i < sizeof(_rules->WarningCodes); i++)
  {
    if (_rules->WarningCodes[i] != InternalWarningCode::NoWarning)
    {
      // Comma if not zero
      if (count)
      {
        response->print(comma);
      }

      response->print(_rules->WarningCodes[i]);
      count++;
    }
  }
  response->print("],");

  // voltages
  response->print(F("\"voltages\":["));

  for (uint8_t i = 0; i < totalModules; i++)
  {
    // Comma if not zero
    if (i)
      response->print(comma);

    if (cmi[i].valid)
    {
      response->print(cmi[i].voltagemV);
    }
    else
    {
      // Module is not yet valid so return null values...
      response->print(null);
    }
  }
  response->print("],");

  response->print(F("\"minvoltages\":["));

  for (uint8_t i = 0; i < totalModules; i++)
  {
    // Comma if not zero
    if (i)
      response->print(comma);

    if (cmi[i].valid)
    {
      response->print(cmi[i].voltagemVMin);
    }
    else
    {
      // Module is not yet valid so return null values...
      response->print(null);
    }
  }
  response->print("],");

  // maxvoltages

  response->print(F("\"maxvoltages\":["));

  for (uint8_t i = 0; i < totalModules; i++)
  {
    // Comma if not zero
    if (i)
      response->print(comma);

    if (cmi[i].valid)
    {
      response->print(cmi[i].voltagemVMax);
    }
    else
    {
      // Module is not yet valid so return null values...
      response->print(null);
    }
  }
  response->print("]");

  response->print(comma);

  // inttemp
  response->print(F("\"inttemp\":["));

  for (uint8_t i = 0; i < totalModules; i++)
  {
    // Comma if not zero
    if (i)
      response->print(comma);

    if (cmi[i].valid && cmi[i].internalTemp != -40)
    {
      response->print(cmi[i].internalTemp);
    }
    else
    {
      // Module is not yet valid so return null values...
      response->print(null);
    }
  }
  response->print("]");

  response->print(comma);

  // exttemp
  response->print(F("\"exttemp\":["));

  for (uint8_t i = 0; i < totalModules; i++)
  {
    // Comma if not zero
    if (i)
      response->print(comma);

    if (cmi[i].valid && cmi[i].externalTemp != -40)
    {
      response->print(cmi[i].externalTemp);
    }
    else
    {
      // Module is not yet valid so return null values...
      response->print(null);
    }
  }
  response->print(']');

  response->print(comma);

  // bypass
  response->print(F("\"bypass\":["));

  for (uint8_t i = 0; i < totalModules; i++)
  {
    // Comma if not zero
    if (i)
      response->print(comma);

    if (cmi[i].valid && cmi[i].inBypass)
    {
      response->print('1');
    }
    else
    {
      response->print('0');
    }
  }
  response->print("]");

  response->print(comma);

  // bypasshot
  response->print(F("\"bypasshot\":["));

  for (uint8_t i = 0; i < totalModules; i++)
  {
    // Comma if not zero
    if (i)
      response->print(comma);

    if (cmi[i].valid && cmi[i].bypassOverTemp)
    {
      response->print('1');
    }
    else
    {
      response->print('0');
    }
  }
  response->print(']');

  response->print(comma);

  // bypasspwm
  response->print(F("\"bypasspwm\":["));

  for (uint8_t i = 0; i < totalModules; i++)
  {
    // Comma if not zero
    if (i)
      response->print(comma);

    if (cmi[i].valid && cmi[i].inBypass)
    {
      response->print(cmi[i].PWMValue);
    }
    else
    {
      response->print('0');
    }
  }
  response->print(']');

  response->print(comma);

  // bypasspwm
  response->print(F("\"bankv\":["));

  for (uint8_t i = 0; i < _mysettings->totalNumberOfBanks; i++)
  {
    // Comma if not zero
    if (i)
      response->print(comma);

    response->print(_rules->packvoltage[i]);
  }
  response->print("]");

  response->print(comma);

  // bypasspwm
  response->print(F("\"voltrange\":["));

  for (uint8_t i = 0; i < _mysettings->totalNumberOfBanks; i++)
  {
    // Comma if not zero
    if (i)
      response->print(comma);

    response->print(_rules->VoltageRangeInBank(i));
  }
  response->print("]");

  response->print(comma);
  response->print(F("\"current\":["));
  if (_mysettings->currentMonitoringEnabled && currentMonitor.validReadings)
  {
    // Output current monitor values, this is inside an array, so could be more than 1
    response->print(F("{\"c\":"));
    response->print(currentMonitor.modbus.current, 4);
    response->print(F(",\"v\":"));
    response->print(currentMonitor.modbus.voltage, 4);
    response->print(F(",\"mahout\":"));
    response->print(currentMonitor.modbus.milliamphour_out);
    response->print(F(",\"mahin\":"));
    response->print(currentMonitor.modbus.milliamphour_in);
    response->print(F(",\"p\":"));
    response->print(currentMonitor.modbus.power, 2);
    response->print(F(",\"soc\":"));
    response->print(currentMonitor.stateofcharge, 2);

    response->print("}");
  }
  else
  {
    response->print(null);
  }

  response->print("]");

  // The END...
  response->print('}');
  response->addHeader("Cache-Control", "no-store");

  request->send(response);
}

String DIYBMSServer::TemplateProcessor(const String &var)
{
  //  ESP_LOGD(TAG, "%s", var.c_str());

  if (var == "XSS_KEY")
    return DIYBMSServer::UUIDString;

#if defined(ESP32)
  if (var == "PLATFORM")
    return String("ESP32");
#endif

  if (var == "LANGUAGE")
    return String(_mysettings->language);

  if (var == "GIT_VERSION")
    return String(GIT_VERSION);

  if (var == "COMPILE_DATE_TIME")
    return String(COMPILE_DATE_TIME);

  //  const DEFAULT_GRAPH_MAX_VOLTAGE = %graph_voltagehigh%;
  //  const DEFAULT_GRAPH_MIN_VOLTAGE = %graph_voltagelow%;

  if (var == "graph_voltagehigh")
    return String(_mysettings->graph_voltagehigh);

  if (var == "graph_voltagelow")
    return String(_mysettings->graph_voltagelow);

  if (var == "integrity_file_jquery_js")
    return String(integrity_file_jquery_js);

  if (var == "noofseriesmodules")
    return String(maximum_controller_cell_modules);

  if (var == "maxnumberofbanks")
    return String(maximum_number_of_banks);

  return String();
}

void DIYBMSServer::SetCacheAndETagGzip(AsyncWebServerResponse *response, String ETag)
{
  response->addHeader("Content-Encoding", "gzip");
  SetCacheAndETag(response, ETag);
}
void DIYBMSServer::SetCacheAndETag(AsyncWebServerResponse *response, String ETag)
{
  response->addHeader("ETag", ETag);
  response->addHeader("Cache-Control", "no-cache, max-age=86400");
}

// Start Web Server (crazy amount of pointer params!)
void DIYBMSServer::StartServer(AsyncWebServer *webserver,
                               diybms_eeprom_settings *mysettings,
                               fs::SDFS *sdcard,
                               PacketRequestGenerator *prg,
                               PacketReceiveProcessor *pktreceiveproc,
                               ControllerState *controlState,
                               Rules *rules,
                               void (*sdcardaction_callback)(uint8_t action),
                               HAL_ESP32 *hal)
{
  _myserver = webserver;
  _hal = hal;
  _prg = prg;
  _controlState = controlState;
  _rules = rules;
  _sdcard = sdcard;
  _mysettings = mysettings;
  _receiveProc = pktreceiveproc;
  _sdcardaction_callback = sdcardaction_callback;

  String cookieValue = "DIYBMS_XSS=";
  cookieValue += DIYBMSServer::UUIDString;
  cookieValue += String("; path=/; HttpOnly");
  DefaultHeaders::Instance().addHeader("Set-Cookie", cookieValue);

  _myserver->on("/", HTTP_GET, [](AsyncWebServerRequest *request)
                { request->redirect("/default.htm"); });

  _myserver->on("/default.htm", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  AsyncWebServerResponse *response = request->beginResponse_P(200, "text/html", (char *)file_default_htm, DIYBMSServer::TemplateProcessor);
                  response->addHeader("Cache-Control", "no-store");
                  request->send(response);
                });

  _myserver->on("/pagecode.js", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  if (request->header("If-None-Match").equals(String(etag_file_pagecode_js_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "application/javascript", file_pagecode_js_gz, size_file_pagecode_js_gz);
                    SetCacheAndETagGzip(response, String(etag_file_pagecode_js_gz));
                    request->send(response);
                  }
                });

  _myserver->on("/favicon.ico", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  if (request->header("If-None-Match").equals(String(etag_file_favicon_ico_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "image/x-icon", file_favicon_ico_gz, size_file_favicon_ico_gz);
                    SetCacheAndETagGzip(response, String(etag_file_favicon_ico_gz));
                    request->send(response);
                  }
                });

  _myserver->on("/logo.png", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  if (request->header("If-None-Match").equals(String(etag_file_logo_png)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "image/png", file_logo_png, size_file_logo_png);
                    SetCacheAndETag(response, String(etag_file_logo_png));
                    request->send(response);
                  }
                });

  _myserver->on("/wait.png", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  if (request->header("If-None-Match").equals(String(etag_file_wait_png)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "image/png", file_wait_png, size_file_wait_png);
                    SetCacheAndETag(response, String(etag_file_wait_png));
                    request->send(response);
                  }
                });

  _myserver->on("/patron.png", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  if (request->header("If-None-Match").equals(String(etag_file_patron_png)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "image/png", file_patron_png, size_file_patron_png);
                    SetCacheAndETag(response, String(etag_file_patron_png));
                    request->send(response);
                  }
                });

  _myserver->on("/warning.png", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  if (request->header("If-None-Match").equals(String(etag_file_warning_png)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "image/png", file_warning_png, size_file_warning_png);
                    SetCacheAndETag(response, String(etag_file_warning_png));
                    request->send(response);
                  }
                });

  _myserver->on("/jquery.js", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  if (request->header("If-None-Match").equals(String(etag_file_jquery_js_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "application/javascript", file_jquery_js_gz, size_file_jquery_js_gz);
                    SetCacheAndETagGzip(response, String(etag_file_jquery_js_gz));
                    request->send(response);
                  }
                });

  _myserver->on("/lang_en.js", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  if (request->header("If-None-Match").equals(String(etag_file_lang_en_js_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "application/javascript", file_lang_en_js_gz, size_file_lang_en_js_gz);
                    SetCacheAndETagGzip(response, String(etag_file_lang_en_js_gz));
                    request->send(response);
                  }
                });

  _myserver->on("/lang_es.js", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  if (request->header("If-None-Match").equals(String(etag_file_lang_es_js_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "application/javascript", file_lang_es_js_gz, size_file_lang_es_js_gz);
                    SetCacheAndETagGzip(response, String(etag_file_lang_es_js_gz));
                    request->send(response);
                  }
                });

  _myserver->on("/lang_de.js", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  if (request->header("If-None-Match").equals(String(etag_file_lang_de_js_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "application/javascript", file_lang_de_js_gz, size_file_lang_de_js_gz);
                    SetCacheAndETagGzip(response, String(etag_file_lang_de_js_gz));
                    request->send(response);
                  }
                });

  _myserver->on("/lang_pt.js", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  if (request->header("If-None-Match").equals(String(etag_file_lang_pt_js_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "application/javascript", file_lang_pt_js_gz, size_file_lang_pt_js_gz);
                    SetCacheAndETagGzip(response, String(etag_file_lang_pt_js_gz));
                    request->send(response);
                  }
                });

  _myserver->on("/lang_nl.js", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  if (request->header("If-None-Match").equals(String(etag_file_lang_nl_js_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "application/javascript", file_lang_nl_js_gz, size_file_lang_nl_js_gz);
                    SetCacheAndETagGzip(response, String(etag_file_lang_nl_js_gz));
                    request->send(response);
                  }
                });
  _myserver->on("/lang_hr.js", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  if (request->header("If-None-Match").equals(String(etag_file_lang_hr_js_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "application/javascript", file_lang_hr_js_gz, size_file_lang_hr_js_gz);
                    SetCacheAndETagGzip(response, String(etag_file_lang_hr_js_gz));
                    request->send(response);
                  }
                });
  _myserver->on("/lang_ru.js", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  if (request->header("If-None-Match").equals(String(etag_file_lang_ru_js_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "application/javascript", file_lang_ru_js_gz, size_file_lang_ru_js_gz);
                    SetCacheAndETagGzip(response, String(etag_file_lang_ru_js_gz));
                    request->send(response);
                  }
                });
  _myserver->on("/echarts.min.js", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  if (request->header("If-None-Match").equals(String(etag_file_echarts_min_js_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "application/javascript", file_echarts_min_js_gz, size_file_echarts_min_js_gz);
                    SetCacheAndETagGzip(response, String(etag_file_echarts_min_js_gz));
                    request->send(response);
                  }
                });

  _myserver->on("/notify.min.js", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  if (request->header("If-None-Match").equals(String(etag_file_notify_min_js_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "application/javascript", file_notify_min_js_gz, size_file_notify_min_js_gz);
                    SetCacheAndETagGzip(response, String(etag_file_notify_min_js_gz));
                    request->send(response);
                  }
                });

  _myserver->on("/style.css", HTTP_GET,
                [](AsyncWebServerRequest *request)
                {
                  if (request->header("If-None-Match").equals(String(etag_file_style_css_gz)))
                  {
                    request->send(304);
                  }
                  else
                  {
                    AsyncWebServerResponse *response = request->beginResponse_P(200, "text/css", file_style_css_gz, size_file_style_css_gz);
                    SetCacheAndETagGzip(response, String(etag_file_style_css_gz));
                    request->send(response);
                  }
                });

  // Read endpoints
  _myserver->on("/monitor2.json", HTTP_GET, DIYBMSServer::monitor2);
  _myserver->on("/monitor3.json", HTTP_GET, DIYBMSServer::monitor3);
  _myserver->on("/integration.json", HTTP_GET, DIYBMSServer::integration);
  _myserver->on("/modules.json", HTTP_GET, DIYBMSServer::modules);
  _myserver->on("/identifyModule.json", HTTP_GET, DIYBMSServer::identifyModule);
  _myserver->on("/settings.json", HTTP_GET, DIYBMSServer::settings);
  _myserver->on("/rules.json", HTTP_GET, DIYBMSServer::GetRules);
  _myserver->on("/storage.json", HTTP_GET, DIYBMSServer::storage);
  _myserver->on("/avrstorage.json", HTTP_GET, DIYBMSServer::avrstorage);
  _myserver->on("/download", HTTP_GET, DIYBMSServer::downloadFile);
  _myserver->on("/avrstatus.json", HTTP_GET, DIYBMSServer::avrstatus);

  _myserver->on("/currentmonitor.json", HTTP_GET, DIYBMSServer::currentmonitor);
  _myserver->on("/rs485settings.json", HTTP_GET, DIYBMSServer::rs485settings);
  _myserver->on("/victron.json", HTTP_GET, DIYBMSServer::getvictron);

  // POST method endpoints
  _myserver->on("/savesetting.json", HTTP_POST, DIYBMSServer::saveSetting);
  _myserver->on("/saveglobalsetting.json", HTTP_POST, DIYBMSServer::saveGlobalSetting);
  _myserver->on("/savemqtt.json", HTTP_POST, DIYBMSServer::saveMQTTSetting);
  _myserver->on("/saveinfluxdb.json", HTTP_POST, DIYBMSServer::saveInfluxDBSetting);
  _myserver->on("/savebankconfig.json", HTTP_POST, DIYBMSServer::saveBankConfiguration);
  _myserver->on("/saverules.json", HTTP_POST, DIYBMSServer::saveRuleConfiguration);
  _myserver->on("/saventp.json", HTTP_POST, DIYBMSServer::saveNTP);
  _myserver->on("/savedisplaysetting.json", HTTP_POST, DIYBMSServer::saveDisplaySetting);
  _myserver->on("/savestorage.json", HTTP_POST, DIYBMSServer::saveStorage);

  _myserver->on("/resetcounters.json", HTTP_POST, DIYBMSServer::resetCounters);
  _myserver->on("/restartcontroller.json", HTTP_POST, DIYBMSServer::handleRestartController);

  _myserver->on("/sdmount.json", HTTP_POST, DIYBMSServer::sdMount);
  _myserver->on("/sdunmount.json", HTTP_POST, DIYBMSServer::sdUnmount);

  _myserver->on("/enableavrprog.json", HTTP_POST, DIYBMSServer::enableAVRprog);
  _myserver->on("/disableavrprog.json", HTTP_POST, DIYBMSServer::disableAVRprog);

  _myserver->on("/avrprog.json", HTTP_POST, DIYBMSServer::avrProgrammer);
  _myserver->on("/wificonfigtofile.json", HTTP_POST, DIYBMSServer::saveWifiConfigToSDCard);
  _myserver->on("/saveconfigtofile.json", HTTP_POST, DIYBMSServer::saveConfigurationToSDCard);

  // Current monitor services/settings
  _myserver->on("/savers485settings.json", HTTP_POST, DIYBMSServer::saveRS485Settings);
  _myserver->on("/savecurrentmon.json", HTTP_POST, DIYBMSServer::saveCurrentMonSettings);
  _myserver->on("/savecmbasic.json", HTTP_POST, DIYBMSServer::saveCurrentMonBasic);
  _myserver->on("/savecmadvanced.json", HTTP_POST, DIYBMSServer::saveCurrentMonAdvanced);
  _myserver->on("/savecmrelay.json", HTTP_POST, DIYBMSServer::saveCurrentMonRelay);
  // Victron stuff
  _myserver->on("/savevictron.json", HTTP_POST, DIYBMSServer::saveVictron);

  _myserver->onNotFound(DIYBMSServer::handleNotFound);
  _myserver->begin();

  ESP_LOGI(TAG, "Start Web Server complete");
}
